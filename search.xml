<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[浅谈React Router中的browserHistory和hashHistory]]></title>
      <url>http://yoursite.com/ciqe201eq0000mswzss6n94m9/</url>
      <content type="html"><![CDATA[<h2 id="React-Router简述"><a href="#React-Router简述" class="headerlink" title="React Router简述"></a>React Router简述</h2><p>React router，即路由，是react生态系统中一个重要的组成部分。它可以使单页应用具有类似于多页应用的<br>路由系统，即前端路由。绝对多数教程中对于Router History中的browserHisotry和hashHistory都是<br>一笔带过：不要用hashHistory，用brwoserHistory，其实在开发中，并没有那么简单，hashhistory也<br>者一定的应用场景，而browserHistory也会有几个坑。</p>
<a id="more"></a>
<h2 id="1-hashHistory-vs-browserHistory"><a href="#1-hashHistory-vs-browserHistory" class="headerlink" title="1. hashHistory vs browserHistory"></a>1. hashHistory vs browserHistory</h2><p>现在，有这么一个简单的小例子：</p>
<p>index.js:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">import React from &apos;react&apos;;</span><br><span class="line">import ReactDOM from &apos;react-dom&apos;;</span><br><span class="line">import &#123; Provider &#125; from &apos;react-redux&apos;;</span><br><span class="line">import &#123; createStore, applyMiddleware &#125; from &apos;redux&apos;;</span><br><span class="line">import &#123; Router, Route, browserHistory, hashHistory&#125; from &apos;react-router&apos;;</span><br><span class="line"></span><br><span class="line">import App from &apos;./components/app&apos;;</span><br><span class="line">import reducers from &apos;./reducers&apos;;</span><br><span class="line">import User from &apos;./components/user&apos;;</span><br><span class="line"></span><br><span class="line">const createStoreWithMiddleware = applyMiddleware()(createStore);</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;Provider store=&#123;createStoreWithMiddleware(reducers)&#125;&gt;</span><br><span class="line">    &lt;Router history=&#123;hashHistory&#125;&gt;</span><br><span class="line">        &lt;Route path=&quot;/&quot; component=&#123;App&#125; &gt;</span><br><span class="line">            &lt;Route path=&quot;user&quot; component=&#123;User&#125; /&gt;</span><br><span class="line">        &lt;/Route&gt;</span><br><span class="line">    &lt;/Router&gt;</span><br><span class="line">  &lt;/Provider&gt;</span><br><span class="line">  , document.querySelector(&apos;.container&apos;));</span><br><span class="line">  </span><br></pre></td></tr></table></figure></p>
<p>app.js:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123; Component &#125; from &apos;react&apos;;</span><br><span class="line">import &#123; Link &#125; from &apos;react-router&apos;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">export default class App extends Component &#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;Link to=&quot;user&quot;&gt;&lt;h2&gt;User&lt;/h2&gt;&lt;/Link&gt;</span><br><span class="line">        &#123;this.props.children&#125;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p>user.js:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123; Component &#125; from &apos;react&apos;;</span><br><span class="line"></span><br><span class="line">export default class User extends Component &#123;</span><br><span class="line">    render()&#123;</span><br><span class="line">        return (</span><br><span class="line">            &lt;h3&gt;User Component&lt;/h3&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="在webpack-dev-server下的运行效果大概是这样："><a href="#在webpack-dev-server下的运行效果大概是这样：" class="headerlink" title="在webpack-dev server下的运行效果大概是这样："></a>在webpack-dev server下的运行效果大概是这样：</h3><p>/<br><img src="/ciqe201eq0000mswzss6n94m9/home_hash.png" alt="home_hash.png" title=""></p>
<p>/user<br><img src="/ciqe201eq0000mswzss6n94m9/user_hash.png" alt="user_hash.png" title=""></p>
<p>注意到地址栏里那一串奇怪的字符串了么（?_k=jgh8bl），这是hashHistory为我们自动添加的，<br>而且，当我们访问/user时，路径也很奇怪。</p>
<h3 id="接下来我们来试着把history-hashHistory-换成history-browserHistory-试试，"><a href="#接下来我们来试着把history-hashHistory-换成history-browserHistory-试试，" class="headerlink" title="接下来我们来试着把history = {hashHistory}换成history = {browserHistory}试试，"></a>接下来我们来试着把<code>history = {hashHistory}</code>换成<code>history = {browserHistory}</code>试试，</h3><p>/<br><img src="/ciqe201eq0000mswzss6n94m9/home_browser.png" alt="home_browser.png" title=""></p>
<p>/user<br><img src="/ciqe201eq0000mswzss6n94m9/user_browser.png" alt="user_browser.png" title=""></p>
<p><em>注意，这里有个小坑，在webpack.config.js中，我们需要在devServer里面加一个</em><br><em><code>historyApiFallback: true</code>的配置项，这一点大家应该都知道，所以就不赘述了。</em></p>
<p>嗯，这次地址栏清爽多了，没有奇怪的字符串，一切都正常了。似乎browserHistory这种<br>方式明显比hashHistory好很多。但是，这里要说一下，如果我们有意不希望用户直接通过<br>地址栏访问user路由的话，就可以使用hashHistory。</p>
<h2 id="2-生产环境"><a href="#2-生产环境" class="headerlink" title="2.生产环境"></a>2.生产环境</h2><p>假如现在项目写完了，需要部署到生产环境下，那么webpack-devserver就不能用了。现在<br>我们需要做两件事：1.写个简单的node服务器，2.用webpack对项目进行打包，生成bundle.js</p>
<h3 id="1-node服务器"><a href="#1-node服务器" class="headerlink" title="1. node服务器"></a>1. node服务器</h3><p>因为整个项目只需要index.html和bundle.js这两个文件，所以我们可以写个简单的静态<br>服务器，这里，我们用express来写，几行代码就能搞定。</p>
<p>server.js:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const express = require(&apos;express&apos;);</span><br><span class="line">const path = require(&apos;path&apos;);</span><br><span class="line"></span><br><span class="line">const app = express();</span><br><span class="line"></span><br><span class="line">app.use(express.static(__dirname));</span><br><span class="line"></span><br><span class="line">app.listen(8080);</span><br></pre></td></tr></table></figure>
<p>当浏览器访问/的时候，服务器就会默认发送index.js给浏览器，由于这个机制的存在，我们不用<br>配置任何路由，注意，这里的路由说的不是前端路由。</p>
<h3 id="2-webpack打包"><a href="#2-webpack打包" class="headerlink" title="2. webpack打包"></a>2. webpack打包</h3><p>webpack.config.js:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">  entry: [</span><br><span class="line">    &apos;./src/index.js&apos;</span><br><span class="line">  ],</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: __dirname,</span><br><span class="line">    publicPath: &apos;/&apos;,</span><br><span class="line">    filename: &apos;bundle.js&apos;</span><br><span class="line">  &#125;,</span><br><span class="line">  module: &#123;</span><br><span class="line">    loaders: [&#123;</span><br><span class="line">      exclude: /node_modules/,</span><br><span class="line">      loader: &apos;babel&apos;,</span><br><span class="line">      query: &#123;</span><br><span class="line">        presets: [&apos;react&apos;, &apos;es2015&apos;, &apos;stage-1&apos;]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;]</span><br><span class="line">  &#125;,</span><br><span class="line">  resolve: &#123;</span><br><span class="line">    extensions: [&apos;&apos;, &apos;.js&apos;, &apos;.jsx&apos;]</span><br><span class="line">  &#125;,</span><br><span class="line">  devServer: &#123;</span><br><span class="line">    historyApiFallback: true,</span><br><span class="line">    contentBase: &apos;./&apos;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在跟路径下打开命令行里输入<code>webpack -p</code>就会生成一个打包好的文件，我们给它起名为bundle.js。<br>现在把webpack-devserver停掉，然后运行server.js，<code>node server.js</code>，之后访问server<br>指定的端口（8080）应该就会看到正常的页面了。</p>
<p>/<br><img src="/ciqe201eq0000mswzss6n94m9/home_browser.png" alt="home_browser.png" title=""></p>
<p>/user<br><img src="/ciqe201eq0000mswzss6n94m9/user_browser.png" alt="user_browser.png" title=""></p>
<p>貌似一切都OK了，但是，当我们在/user下刷新一下时就不太OK了。。。<br>/user<br><img src="/ciqe201eq0000mswzss6n94m9/user_error.png" alt="user_error.png" title=""></p>
<p>页面中显示的”Cannot GET user”是express给我们响应回来的内容，并不是我们刚才写的user.js，<br>也就是说，浏览器并没有使用我们react-router中给出的路由。</p>
<p>其实原因很简单，因为react-router中的路由实际上是前端路由，并不是真正意义上的路由。说白了，<br>不管你请求什么地址，前端路由都不会让浏览器向服务器发送请求，而是在前端直接做处理，然后给用户<br>看相应的页面，也就是说，无论用户请求什么路径，其实用户一直都是在index页面上。</p>
<p>这一点我们同样可以在浏览器的console里的Network中得到证实，理论上，当我们点击user链接或者在<br>浏览器中手动切换到/user时，浏览器并没有向服务器请求新的页面。但是，当我们真的部署到生产环境时，<br>在浏览器手动切换/user或者刷新时，浏览器并不知道我们其实是想让前端路由来做处理并且不发送请求给<br>服务器的，所以依然会发请求给服务器，请求/user，然后服务器没有相关的配置，所以就返回一个默认的<br>404页面给浏览器。</p>
<p>如果我们这里使用的是hashHistory，就不会有这个问题，因为hashHistory在路径后面加了一个#符号，<br>这就相当于告诉浏览器不要向服务器发请求。</p>
<h3 id="3-改进server-js"><a href="#3-改进server-js" class="headerlink" title="3. 改进server.js"></a>3. 改进server.js</h3><p>这里我们如果仍然想使用browserHistory的话，就要对服务器端进行改进，其实做法很简单，就是添加一个<br>匹配所有路径的配置，然后让这个配置返回index.html，也就是说无论浏览器请求什么路径，都会返回index.html<br>然后浏览器的前端路由（react-router）就能开始工作了。</p>
<p>server.js:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">const express = require(&apos;express&apos;);</span><br><span class="line">const path = require(&apos;path&apos;);</span><br><span class="line"></span><br><span class="line">const app = express();</span><br><span class="line"></span><br><span class="line">app.use(express.static(__dirname));</span><br><span class="line"></span><br><span class="line">app.get(&apos;*&apos;, (req, res)=&gt;&#123;</span><br><span class="line">    res.sendFile(path.resolve(__dirname, &apos;index.html&apos;));</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.listen(8080);</span><br></pre></td></tr></table></figure>
<p>然后重启服务器，一切就正常了，而且没有向在切换到/user时向服务器发送新的请求，这说明前端路由也能正常<br>工作了。而且，当我们访问一个不存在的路径时，比如(/abcde)，服务器也没有显示默认的<code>Cannot GET</code>页面<br>而是在控制台里报了个warning，说不能找到相应的路径。</p>
<h3 id="4-关于其他路径"><a href="#4-关于其他路径" class="headerlink" title="4. 关于其他路径"></a>4. 关于其他路径</h3><p>也许会有同学问，如果我的服务器还配置了一套API在/api路径下，那么这套API是不是就不能用了。答案是不会。<br>但是我们要把这些配置卸载<code>app.get(&#39;*&#39;)</code>之前。因为express是按照配置的顺序来对请求进行匹配的，如果写<br>在<code>app.get(&#39;*&#39;)</code>之后，就会先匹配到/*，因为成功匹配上了，就会返回index.html。</p>
<p>server.js:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">const express = require(&apos;express&apos;);</span><br><span class="line">const path = require(&apos;path&apos;);</span><br><span class="line"></span><br><span class="line">const app = express();</span><br><span class="line"></span><br><span class="line">app.use(express.static(__dirname));</span><br><span class="line"></span><br><span class="line">app.get(&apos;/api&apos;, (req, res)=&gt;&#123;</span><br><span class="line">    res.json(&#123;username: &apos;abc&apos;&#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.get(&apos;*&apos;, (req, res)=&gt;&#123;</span><br><span class="line">    res.sendFile(path.resolve(__dirname, &apos;index.html&apos;));</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.listen(8080);</span><br></pre></td></tr></table></figure>
<p>这时我们访问/和/user时，一切正常，并且当我们访问/api时，也可以得到相应的内容。</p>
<p>/api<br><img src="/ciqe201eq0000mswzss6n94m9/api_img.png" alt="api_img.png" title=""></p>
<h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h2><p>我们简略的分析了一下browserHistory和hashHistory的一些区别，并且做了个简单的<br>生产环境部署，以及踩了browserHistory在生产环境下的一个小坑。总的来说，一般情况<br>下我们都会选用在地址栏显示清爽的browserHistory，但是在一些情况下，hashHistory<br>也有者它的好处。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Node中的事件系统]]></title>
      <url>http://yoursite.com/ciqe201iu000cmswz86fa12ou/</url>
      <content type="html"><![CDATA[<h2 id="Node中的事件发布与订阅"><a href="#Node中的事件发布与订阅" class="headerlink" title="Node中的事件发布与订阅"></a>Node中的事件发布与订阅</h2><p>事件的发布和订阅系统(event)是NodeJS中的一个极为重要的系统，但是这个系统对于很多刚入坑的小伙伴来说可能难以理解，<br>这篇博客会为刚入坑的小伙伴们简单介绍一下事件（event），并且一步一步的写一个“山寨版”的事件系统。</p>
<a id="more"></a>
<h3 id="1-什么是事件系统"><a href="#1-什么是事件系统" class="headerlink" title="1. 什么是事件系统"></a>1. 什么是事件系统</h3><p>事件系统其实就是NodeJS中的一个模块（Events），这个模块使得NodeJS具有对事件的监听和触发的动能。<br>比如说，我们可以制定一个机制，一旦一个文件读取完毕，我们会做什么事情，比如将文件内容打印出来或者进行修改。<br>事件系统是NodeJS中的一个极其重要的系统，因为Javascript语言原本是前端的脚本语言，对于这种事件机制支持<br>比较弱，而这种机制又是后端语言必备的，所以NodeJS实现了一套很完善的事件系统。许多初识Node的同学可能<br>会觉得事件机制比较难理解，但其实真没有那么难。</p>
<h3 id="2-如何使用事件系统"><a href="#2-如何使用事件系统" class="headerlink" title="2. 如何使用事件系统"></a>2. 如何使用事件系统</h3><p>在NodeJS中有个模块叫做Events，它的作用就是让我们很容易的去使用事件。</p>
<ol>
<li><p>首先，要导入events模块。由于这个模块是一个构造函数，所以我们需要new一个event实例。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var Events = require(&apos;events&apos;);</span><br><span class="line"></span><br><span class="line">var myEvent = new Events();</span><br></pre></td></tr></table></figure>
</li>
<li><p>在这个实例的原型上有很多方法，这里只说两个最简单的，其他的可以在<a href="https://nodejs.org/dist/latest-v6.x/docs/api/events.html" target="_blank" rel="external">NodeJS的官方API</a>上面看到。<br><em>on</em>方法负责定义事件并且绑定到一个监听者（listener）上，就像这样</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">myEvent.on(&apos;hello&apos;, function()&#123;</span><br><span class="line">    console.log(&apos;hello back&apos;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>这里，我们定义了一个名为hello的事件，而监听者一旦发现这个事件被触发了，就会执行function里面的内容。</p>
</li>
<li><p>一个事件上可以绑定多个监听者，所以我们再为这个名为hello的事件绑定一个吧</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">myEvent.on(&apos;hello&apos;, function()&#123;</span><br><span class="line">    console.log(&apos;Ignored&apos;)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>事件绑定好了，我们来触发一下这个事件，看看我们绑定的监听者会不会生效，然而触发事件我们<br>只需要调用它的emit方法就可以了，就像这样</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myEvent.emit(&apos;hello&apos;);</span><br></pre></td></tr></table></figure>
<p>执行的结果如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hello back</span><br><span class="line">Ignored</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="3-自己写一个山寨版的事件系统"><a href="#3-自己写一个山寨版的事件系统" class="headerlink" title="3.自己写一个山寨版的事件系统"></a>3.自己写一个山寨版的事件系统</h3><p>在学习编程中有一个很好的方法，就是 “山寨”，或者发明轮子，其实就是通过实现一个已经有的功能来加深对这个<br>功能的理解，那么我们也来“山寨”一个最简单的事件系统吧，来看看事件到底是个什么东西。</p>
<ol>
<li><p>首先，我们知道了NodeJS的事件模块是个构造函数，所以我们也来写一个构造函数。这里我们给一个空对象，这个对象会<br>用来存放各类的事件（event），比如之前我们用过的hello事件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function Events()&#123;</span><br><span class="line">    this.events = &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>刚才我们一共使用了两个方法，on和emit对吧，这里我们也要在原型上扩展这两个方法，以达到让“山寨版”可以像“正版”一样工作。<br>首先on可以接受两个参数，一个是事件的名字（hello），另一个是事件触发时需要执行的方法，而emit只需要接受一个事件名就可以了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Events.prototype.on = function(type, responseFunction)&#123;</span><br><span class="line">  </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Events.prototype.emit = function(type)&#123;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>想想当on方法执行时发生了什么，它把一个方法绑定到一个事件上了，所以大概是这样的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Events.prototype.on = function(type, responseFunction)&#123;</span><br><span class="line">    this.events[type] = responseFunction;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这里说明一下，在</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function Events()&#123;</span><br><span class="line">    this.events = &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>中，this.events这个object大概会是一个这样的结构，每个受到绑定的事件都会对应相应的方法，就像这样</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    hello: function()&#123;...&#125;,</span><br><span class="line">    fileLoaded: function()&#123;...&#125;,</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>比如，当hello被触发时，里面的function就会执行。</p>
</li>
<li><p>同理，我们再来想想当调用了emit方法时发生了什么，对，事件对应的方法被执行了，所以大概会是这样，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Events.prototype.emit = function(type)&#123;</span><br><span class="line">    this.events[type]();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>注意，这里说明一下，我们调用某个object上的一个方法或者访问这个object上的某个属性时，可以通过两种方法：<br>一是通过打点的方法，比如<code>obj.xxx</code>（属性），<code>obj.xxx()</code>（方法）；<br>二是通过方括号的方法，比如<code>obj[&#39;xxx&#39;]</code>（属性），<code>obj[&#39;xxx&#39;]()</code>（方法）。<br>但是这里我们只能用后者，因为我们不是要调用this.events的type属性而是要调用通过type传进来的那个属性，<br>换句话说，type是个变量，它的值才是我们真正要调用的，比如events.hello。</p>
</li>
<li><p>好了，这样就差不多了。哦，对了！一会别的文件要引用这个模块，所以我们要导出一下，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">module.exports = Events;</span><br></pre></td></tr></table></figure>
</li>
<li><p>来执行一下吧，把刚才的<code>require(&#39;events&#39;)</code>换成我们的“山寨版”吧<code>require(&#39;./modules/myEvents&#39;)</code>，<br>走起！！！<br>输出：<br><code>Ignored</code><br>Yeah！！！<br>等等，好像哪里不对啊，刚才明明绑定了两个监听者现在怎么只输出了一个啊？这什么情况。。。</p>
</li>
</ol>
<h3 id="3-山寨版改造"><a href="#3-山寨版改造" class="headerlink" title="3.山寨版改造"></a>3.山寨版改造</h3><ol>
<li><p>通过分析刚才我们写的代码，很明显，每次我们调用on方法时，会给event实例重新赋值，换句话说，之后的会覆盖之前的，<br>所以要让我们的“山寨版具有和”正版一样对一个事件多次绑定的功能，我们需要用一个集合来存放同一事件绑定的所有监听者，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Events.prototype.on = function(type, responseFunction)&#123;</span><br><span class="line">    if(this.events[type])&#123;</span><br><span class="line">        this.events[type].push(responseFunction);</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        this.events[type] = [];</span><br><span class="line">        this.events[type].push(responseFunction);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这里的逻辑是，如果一个事件（event）之前已经定义过了，那我们就直接在这个事件所对应的监听者数组里push新绑定的方法，<br>如果没有定义过，那么就定义一个空监听者数组，然后把对应的方法push进去。说白了，第一次我们绑定hello这个事件的时候，<br>实例的events上并没有这个叫hello的属性，那么我们定义一个数组，然后把hello对应的方法push进去，第二次我们发现已经<br>有hello了，就在相应的数组里push一个新的方法。hello这个事件大概是这样的<br>第一次：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//on执行前</span><br><span class="line">events:&#123;&#125;</span><br><span class="line">//on执行后</span><br><span class="line">events:&#123;</span><br><span class="line">    hello: [function()&#123;...&#125;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第二次</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//on执行前</span><br><span class="line">events:&#123;</span><br><span class="line">    hello: [function()&#123;...&#125;]</span><br><span class="line">&#125;</span><br><span class="line">//on执行后</span><br><span class="line">events:&#123;</span><br><span class="line">    hello: [function()&#123;...&#125;, function()&#123;...&#125;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以对这段代码进行一下简化，说白了就是想少写点字</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Events.prototype.on = function(type, responseFunction)&#123;</span><br><span class="line">    this.events[type] = this.events[type] || [];</span><br><span class="line">    this.events[type].push(responseFunction);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>OK，on这个方法就大概写完了。</p>
</li>
<li><p>既然events.hello已经是一个包含了多个function的数组，所以我们不能像之前那样<br><code>this.events[type]();</code>简单粗暴的直接调用了，我们需要执行数组里的每一个function，也就是<br>对这个数组进行一下遍历，这里有很多种方法，我们用forEach，因为效率比较高。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Events.prototype.emit = function(type)&#123;</span><br><span class="line">    this.events[type].forEach(function(responseFunc)&#123;</span><br><span class="line">        responseFunc();</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>好了，到这里这个“山寨版”也就差不多完成了，我们来跑跑吧：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hello back</span><br><span class="line">Ignored</span><br></pre></td></tr></table></figure>
<p>非常好！这样我们的“山寨版”也能绑定多个监听者了。</p>
</li>
</ol>
<p>完整代码如下<br>./modules/myEvents.js<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function Events()&#123;</span><br><span class="line">    this.events = &#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Events.prototype.on = function(type, responseFunction)&#123;</span><br><span class="line">    this.events[type] = this.events[type] || [];</span><br><span class="line">    this.events[type].push(responseFunction);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Events.prototype.emit = function(type)&#123;</span><br><span class="line">    this.events[type].forEach(function(responseFunc)&#123;</span><br><span class="line">        responseFunc();</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">module.exports = Events;</span><br></pre></td></tr></table></figure></p>
<p>./app.js<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var Events = require(&apos;./modules/myEvents&apos;);</span><br><span class="line"></span><br><span class="line">var myEvent = new Events();</span><br><span class="line"></span><br><span class="line">myEvent.on(&apos;hello&apos;, function()&#123;</span><br><span class="line">    console.log(&apos;hello back&apos;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">myEvent.on(&apos;hello&apos;, function()&#123;</span><br><span class="line">    console.log(&apos;Ignored&apos;)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">myEvent.emit(&apos;hello&apos;);</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<h3 id="4-总结"><a href="#4-总结" class="headerlink" title="4.总结"></a>4.总结</h3><p>我们写了一个“山寨版”的事件绑定和发布系统，但是山寨毕竟是山寨，我们看看NodeJS源码中的Events模块。。。<br><strong>我滴神呐。。。同样是程序猿，代码的差距咋就这么大捏。。。</strong><br>那是当然，人家的代码有很多我们没有的方法，而且人家有很多异常处理等等。但是如果你仔细看正版的on和emit方法<br>会发现其实他们实现的方法和我们的差不太多，那是当然，我是看过源码才。。。我是说。。。我是受到了源码的启发<br>才写的这篇博客。</p>
<h3 id="5-参考资料"><a href="#5-参考资料" class="headerlink" title="5.参考资料"></a>5.参考资料</h3><ol>
<li><a href="https://nodejs.org/dist/latest-v6.x/docs/api/events.html" target="_blank" rel="external">官方文档</a></li>
<li><a href="https://github.com/nodejs/node" target="_blank" rel="external">NodeJS源码</a></li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Node中的module和require]]></title>
      <url>http://yoursite.com/ciqe201ez0002mswzz1av3jm1/</url>
      <content type="html"><![CDATA[<h2 id="Node中的模块"><a href="#Node中的模块" class="headerlink" title="Node中的模块"></a>Node中的模块</h2><p>在Node中，很大的一个组成部分就是模块，其中有Node中的core模块，有从npm上下载的第三方模块以及我们自己写的模块。<br>NodeJS在模块化方面使用的是exports和require来导入和导出。</p>
<a id="more"></a>
<p>这里我写了几个小例子来和大家分享一下exports的几种简单方法。文件目录大概是这样</p>
<img src="/ciqe201ez0002mswzz1av3jm1/module_example.png" alt="module_example.png" title="">
<h3 id="1-直接导出"><a href="#1-直接导出" class="headerlink" title="1.直接导出"></a>1.直接导出</h3><p> ./modules/hello1.js<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">module.exports = function()&#123;</span><br><span class="line">    console.log(&apos;hello world 1&apos;)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>这是一种很简单的到处方法，module.expots可以理解成是一个空对象（{}），而导出的方法就是直接用自己写好的function或者<br>object来替换这个对象。</p>
<p> ./app.js<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var hello1 = require(&apos;./modules/hello1&apos;);</span><br><span class="line">hello1();</span><br></pre></td></tr></table></figure></p>
<h3 id="2-作为exports的一个属性导出"><a href="#2-作为exports的一个属性导出" class="headerlink" title="2.作为exports的一个属性导出"></a>2.作为exports的一个属性导出</h3><p> ./modules/hello2.js<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var hello = function()&#123;</span><br><span class="line">    console.log(&apos;hello world 2&apos;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">module.exports.hello = hello;</span><br></pre></td></tr></table></figure><br>为module.exports增加一个名为hello的属性</p>
<p> ./app.js<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var hello2 = require(&apos;./modules/hello2&apos;);</span><br><span class="line">hello2.hello();</span><br></pre></td></tr></table></figure></p>
<h3 id="3-用一个实例来替换module-exports"><a href="#3-用一个实例来替换module-exports" class="headerlink" title="3. 用一个实例来替换module.exports"></a>3. 用一个实例来替换module.exports</h3><p> ./modules/hello3.js<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var hello3 = function()&#123;</span><br><span class="line">    this.word = &apos;hello world 3&apos;;</span><br><span class="line">    this.hello = function()&#123;</span><br><span class="line">        console.log(this.word)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">module.exports = new hello3();</span><br></pre></td></tr></table></figure><br>这里可以看到，首先我们写一个构造函数用来生成实例，然后把一个新生成的实例赋给module.exports，就像这样：</p>
<p> ./app.js<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var hello3a = require(&apos;./modules/hello3&apos;);</span><br><span class="line">hello3a.hello();</span><br></pre></td></tr></table></figure><br>但是，如果我们改变hello3a的属性会怎么样呢？按理说实例都是各自独立的，hello3a的属性改变了应该不会影响其他的实例啊，<br>让我们来做个实验吧</p>
<ul>
<li>./app.js<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var hello3a = require(&apos;./modules/hello3&apos;);</span><br><span class="line">hello3a.hello();</span><br><span class="line">//这里word属性已经改变了</span><br><span class="line">hello3a.word = &apos;Good bye&apos;;</span><br><span class="line"></span><br><span class="line">var hello3b = require(&apos;./modules/hello3&apos;);</span><br><span class="line">hello3b.hello();</span><br><span class="line"></span><br><span class="line">//输出是这样的</span><br><span class="line">//hello world 3</span><br><span class="line">//Good bye</span><br></pre></td></tr></table></figure>
为什么啊？！我不是只改变了hello3a的word属性吗，为什么hello3b也会受到影响？！<br>其实，module.exports是有缓存机制的，只要一个模块生成了一次，之后所有对这个模块的require都会判断是否存在这个模块的缓存，<br>如果有，就会返回这份缓存。也就是说，不管一个模块被require多少次，其实都是require的同一个模块。那么上面的例子我该怎么让这两个实例<br>真正的做到独立存在呢？</li>
</ul>
<h3 id="4-导出一个构造函数"><a href="#4-导出一个构造函数" class="headerlink" title="4. 导出一个构造函数"></a>4. 导出一个构造函数</h3><p> ./modules/hello4.js<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var HelloCreator = function()&#123;</span><br><span class="line">    this.word = &apos;hello world 4&apos;;</span><br><span class="line">    this.hello = function()&#123;</span><br><span class="line">        console.log(this.word);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">module.exports = HelloCreator;</span><br></pre></td></tr></table></figure><br>其实很简单，只要导出那个构造函数就行了，谁需要实例就去自己new吧</p>
<p> ./app.js<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var Hello = require(&apos;./modules/hello4&apos;);</span><br><span class="line">var hello4a = new Hello();</span><br><span class="line"></span><br><span class="line">hello4a.word = &apos;Good bye&apos;;</span><br><span class="line">hello4a.hello();</span><br><span class="line"></span><br><span class="line">var hello4b = new Hello();</span><br><span class="line">hello4b.hello();</span><br></pre></td></tr></table></figure><br>当然了，我们不能直接使用这个模块，因为它仅仅只是个构造函数，所以只要new一下就可以了。</p>
<h3 id="5-只把想要暴露的方法和属性暴露出去"><a href="#5-只把想要暴露的方法和属性暴露出去" class="headerlink" title="5. 只把想要暴露的方法和属性暴露出去"></a>5. 只把想要暴露的方法和属性暴露出去</h3><p> ./modules/hello5.js<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var word = &apos;Hello world 5&apos;;</span><br><span class="line">var word2 = &apos;Good bye&apos;;</span><br><span class="line"></span><br><span class="line">var hello = function()&#123;</span><br><span class="line">    console.log(word);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var bye = function()&#123;</span><br><span class="line">    console.log(word2);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">    hello: hello,</span><br><span class="line">    bye: bye</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>在这个例子里，我们只把hello和bye这两个方法暴露给外界，对于其他的属性和方法，外界是无法访问到的。这样做在某种意义上保证了隐秘数据不会被外界<br>访问到，而且还增加了模块的可控性。</p>
<p> ./app.js<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var hello5 = require(&apos;./modules/hello5&apos;);</span><br><span class="line">hello5.hello();</span><br><span class="line">hello5.bye();</span><br></pre></td></tr></table></figure></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>定义模块和获得模块的方法有很多，以上只是列举了几种比较常见的，希望能对新入坑的小伙伴们有所帮助。其实我认为没有哪种方法是绝对好或者绝对不好的<br>具体使用哪种方法写模块或者导出模块还是要看具体的业务需求。</p>
]]></content>
    </entry>
    
  
  
</search>
