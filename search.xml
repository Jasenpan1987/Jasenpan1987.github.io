<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[reselect与redux]]></title>
      <url>http://yoursite.com/ciqfij0lv0003lcwzu762rg90/</url>
      <content type="html"><![CDATA[<h2 id="1-reselect简介"><a href="#1-reselect简介" class="headerlink" title="1. reselect简介"></a>1. reselect简介</h2><p>reselect是一个与redux配合使用的一个模块，它可根据state上的多个已有的属性来生成一个新的属性，<br>这可以为简化代码逻辑带来很大的帮助。比如我们在state上有users这个属性，而在每个user上又有性别<br>这个属性，那么我们可以使用reselect来为我们分别生成性别为男和女的新属性，而且也不需要加入新的<br>reducer和action。</p>
<a id="more"></a>
<h2 id="2-一个简单的例子"><a href="#2-一个简单的例子" class="headerlink" title="2. 一个简单的例子"></a>2. 一个简单的例子</h2><h3 id="现在我们有一个简单的文章系统，大概是这样的："><a href="#现在我们有一个简单的文章系统，大概是这样的：" class="headerlink" title="现在我们有一个简单的文章系统，大概是这样的："></a>现在我们有一个简单的文章系统，大概是这样的：</h3><img src="/ciqfij0lv0003lcwzu762rg90/articles_1.png" alt="articles_1.png" title="">
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="文件目录大概这样："><a href="#文件目录大概这样：" class="headerlink" title="文件目录大概这样："></a>文件目录大概这样：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">|- actions/</span><br><span class="line">|--- types.js  //存放所有action.type</span><br><span class="line">|--- index.js   //action creators</span><br><span class="line">|- components/</span><br><span class="line">|--- app.js    //入口组件</span><br><span class="line">|--- containers/</span><br><span class="line">|------ post_list.js //显示已被选中的文章</span><br><span class="line">|------ post_selectors.js    //所有文章，点击checkbox会加入被选中的文章列表</span><br><span class="line">|- reducers/</span><br><span class="line">|--- all_post_reducer.js  //返回所有文章</span><br><span class="line">|--- index.js     //combinedReducer</span><br><span class="line">|--- select_post_reducer.js   //返回被选中或者被反选的文章</span><br><span class="line">|-index.js  //主入口</span><br></pre></td></tr></table></figure>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><p><strong> /index.js </strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">import React from &apos;react&apos;;</span><br><span class="line">import ReactDOM from &apos;react-dom&apos;;</span><br><span class="line">import &#123; Provider &#125; from &apos;react-redux&apos;;</span><br><span class="line">import &#123; createStore, applyMiddleware &#125; from &apos;redux&apos;;</span><br><span class="line">import reduxThunk from &apos;redux-thunk&apos;;</span><br><span class="line"></span><br><span class="line">import App from &apos;./components/app&apos;;</span><br><span class="line">import reducers from &apos;./reducers&apos;;</span><br><span class="line"></span><br><span class="line">const createStoreWithMiddleware = applyMiddleware(</span><br><span class="line">    reduxThunk</span><br><span class="line">)(createStore);</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;Provider store=&#123;createStoreWithMiddleware(reducers)&#125;&gt;</span><br><span class="line">    &lt;App /&gt;</span><br><span class="line">  &lt;/Provider&gt;</span><br><span class="line">  , document.querySelector(&apos;.container&apos;));</span><br></pre></td></tr></table></figure></p>
<p><strong> /components/app.js </strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123; Component &#125; from &apos;react&apos;;</span><br><span class="line"></span><br><span class="line">import PostSelector from &apos;./containers/post_selectors&apos;;</span><br><span class="line">import PostList from &apos;./containers/post_list&apos;</span><br><span class="line"></span><br><span class="line">export default class App extends Component &#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;PostList /&gt;</span><br><span class="line">        &lt;PostSelector /&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong> /components/containers/post_selectors.js </strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123; Component &#125; from &apos;react&apos;;</span><br><span class="line">import &#123; connect &#125; from &apos;react-redux&apos;;</span><br><span class="line">import &#123; bindActionCreators &#125; from &apos;redux&apos;</span><br><span class="line"></span><br><span class="line">import &#123; getPosts, selectPost, deselectPost &#125; from &apos;../../actions/index&apos;;</span><br><span class="line"></span><br><span class="line">class PostSelector extends Component &#123;</span><br><span class="line">    componentWillMount()&#123;</span><br><span class="line">        this.props.getPosts();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    handleCheck(postId, event)&#123;</span><br><span class="line">        if(event.target.checked)&#123;</span><br><span class="line">            this.props.selectPost(postId)</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            this.props.deselectPost(postId)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    renderPostList()&#123;</span><br><span class="line">        return this.props.posts.map(post =&gt; &#123;</span><br><span class="line">            return (</span><br><span class="line">                &lt;li className=&quot;list-group-item&quot; key=&#123;post.id&#125;&gt;</span><br><span class="line">                    &lt;input</span><br><span class="line">                        type=&quot;checkbox&quot;</span><br><span class="line">                        value=&#123;this.props.selectedIds.includes(post.id)&#125;</span><br><span class="line">                        onChange=&#123;this.handleCheck.bind(this, post.id)&#125;</span><br><span class="line">                    /&gt;</span><br><span class="line">                    &#123;post.title&#125;</span><br><span class="line">                &lt;/li&gt;</span><br><span class="line">            )</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    render()&#123;</span><br><span class="line">        //console.log(this.props.posts)</span><br><span class="line">       if(this.props.posts)&#123;</span><br><span class="line">           return (</span><br><span class="line">               &lt;div&gt;</span><br><span class="line">                   &lt;h2&gt;文章列表&lt;/h2&gt;</span><br><span class="line">                   &lt;ul className=&quot;list-group&quot;&gt;</span><br><span class="line">                       &#123;this.renderPostList()&#125;</span><br><span class="line">                   &lt;/ul&gt;</span><br><span class="line">               &lt;/div&gt;</span><br><span class="line">           )</span><br><span class="line">       &#125;else&#123;</span><br><span class="line">           return &lt;h2&gt;Loading...&lt;/h2&gt;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function mapStateToProps(state)&#123;</span><br><span class="line">    return &#123;</span><br><span class="line">        posts: state.posts,</span><br><span class="line">        selectedIds: state.selectedIds</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function mapDispatchToProps(dispatch)&#123;</span><br><span class="line">    return bindActionCreators(&#123;</span><br><span class="line">        getPosts,</span><br><span class="line">        selectPost,</span><br><span class="line">        deselectPost</span><br><span class="line">    &#125;, dispatch)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default connect(mapStateToProps, mapDispatchToProps)(PostSelector);</span><br></pre></td></tr></table></figure></p>
<p><strong> /components/containers/post_list.js </strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123; Component &#125; from &apos;react&apos;;</span><br><span class="line"></span><br><span class="line">export default class PostList extends Component &#123;</span><br><span class="line">    render()&#123;</span><br><span class="line">        return (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;h2&gt;已选中的文章&lt;/h2&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong> /actions/types.js </strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">export const GETPOSTS = &apos;GETPOSTS&apos;;</span><br><span class="line">export const SELECTPOST = &apos;SELECTPOST&apos;;</span><br><span class="line">export const DESELECTPOST = &apos;DESELECTPOST&apos;;</span><br></pre></td></tr></table></figure></p>
<p><strong> /actions/index.js </strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">import axios from &apos;axios&apos;;</span><br><span class="line">import _ from &apos;lodash&apos;;</span><br><span class="line"></span><br><span class="line">import &#123; GETPOSTS, SELECTPOST, DESELECTPOST &#125; from &apos;./types&apos;;</span><br><span class="line"></span><br><span class="line">export function getPosts()&#123;</span><br><span class="line">    return dispatch =&gt; &#123;</span><br><span class="line">        const fetchUrl = &apos;http://jsonplaceholder.typicode.com/posts&apos;;</span><br><span class="line">        axios.get(fetchUrl).then(response=&gt;&#123;</span><br><span class="line">            if(response.status == 200)&#123;</span><br><span class="line">                dispatch(&#123;</span><br><span class="line">                    type: GETPOSTS,</span><br><span class="line">                    payload: response.data.slice(0, 5)</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export function selectPost(postId)&#123;</span><br><span class="line">    return dispatch =&gt; &#123;</span><br><span class="line">        dispatch(&#123;</span><br><span class="line">            type: SELECTPOST,</span><br><span class="line">            payload: postId</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export function deselectPost(postId)&#123;</span><br><span class="line">    return &#123;</span><br><span class="line">        type: DESELECTPOST,</span><br><span class="line">        payload: postId</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong> /reducers/index.js </strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import &#123; combineReducers &#125; from &apos;redux&apos;;</span><br><span class="line">import all_post_reducer from &apos;./all_post_reducer&apos;;</span><br><span class="line">import select_post_reducer from &apos;./select_post_reducer&apos;;</span><br><span class="line"></span><br><span class="line">const rootReducer = combineReducers(&#123;</span><br><span class="line">  posts: all_post_reducer,</span><br><span class="line">  selectedIds: select_post_reducer</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">export default rootReducer;</span><br></pre></td></tr></table></figure></p>
<p><strong> /reducers/all_post_reducer.js </strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">import &#123; GETPOSTS, SELECTPOST, DESELECTPOST &#125; from &apos;../actions/types&apos;;</span><br><span class="line"></span><br><span class="line">export default function(state=[], action)&#123;</span><br><span class="line">    switch(action.type)&#123;</span><br><span class="line">        case GETPOSTS:</span><br><span class="line">            return action.payload;</span><br><span class="line"></span><br><span class="line">        default:</span><br><span class="line">            return state;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong> /reducers/select_post_reducer.js </strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">import &#123; GETPOSTS, SELECTPOST, DESELECTPOST &#125; from &apos;../actions/types&apos;;</span><br><span class="line"></span><br><span class="line">export default function(state=[], action)&#123;</span><br><span class="line">    switch(action.type)&#123;</span><br><span class="line">        case SELECTPOST:</span><br><span class="line">            return [...state, action.payload];</span><br><span class="line"></span><br><span class="line">        case DESELECTPOST:</span><br><span class="line">            return state.filter(id=&gt; id!=action.payload);</span><br><span class="line"></span><br><span class="line">        default:</span><br><span class="line">            return state;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="代码概述："><a href="#代码概述：" class="headerlink" title="代码概述："></a>代码概述：</h3><p>这是一个很简单的react-redux项目，通过两个action creator来向reducer发送action，并且<br>生成新的state，这里state中共有两个属性，1，包含所有文章的数组，这里可以看出来，我们使用的是jsonplaceholder<br>中的post并且只取了前5个。2，包含所有已经被选的文章Id数组，这个数组只包含文章的Id，大概是这样的<br><code>[1, 2, 4]</code>。用户可以通过选择活反选文章左侧的checkbox来进行选择或者反选文章，其实就是往被选文章数组内<br>添加当前文章Id或者是从被选文章数组内移除当前文章的Id。</p>
<h3 id="一点题外话"><a href="#一点题外话" class="headerlink" title="一点题外话"></a>一点题外话</h3><p>我在写这个小例子的时候除了个小状况，而且，我觉得应该很多人都出过这种状况吧。当时我差不多写好的时候，<br>发现不管是选择还是反选文章前的checkbox，被选文章的数组始终是个空数组，经过一番排查，发现错误很诡异<br>action creator方法确实执行了，但是reducer却没有反应，而且浏览器没有报任何错误，换句话说，reducer<br>没有接收到action creator发出的action。经过长(da)时(shen)间(de)调(zhi)试(dian)，最终发现bug的所在：<br><strong> 我在组件中调用actioncreator 方法的时候忘了加 this.props </strong> 这么做会导致在action creator被<br>调用的时候，它调用的不是props上的那个redux包装过的action creator，而是调用的import进来的那个包装前的。<br>要知道，在bindActionCreator执行的时候，里面的方法已经跟redux绑定在了一起，但是之前那个import进来的<br>只是一个纯函数，可以执行，然后return一个action object，并不会dispatch给reducer。这个错误我觉的应该<br>不是我一个人犯过，所以大家看了以后，如果你的action creator可以正常以运行但是reducer却接不到任何一个<br>action，而且浏览器不报任何错误，那么多半就是这个原因了，检查一下你在运行action creator的时候是不是<br>忘了加this.props吧。</p>
<h2 id="3-补全post-list"><a href="#3-补全post-list" class="headerlink" title="3. 补全post_list"></a>3. 补全post_list</h2><p>可以看出来，post_list根本就没写完，目前，它只能显示一个h2标签。我们需要它在有文章被勾选时显示这个文章，<br>再文章被反选时把这个文章移除。那么很明显，它需要是一个Smart Component，就是说它需要和state tree相关联。</p>
<h3 id="state-tree已绑定的属性"><a href="#state-tree已绑定的属性" class="headerlink" title="state tree已绑定的属性"></a>state tree已绑定的属性</h3><p>目前我们的state tree上已经绑定了这些：</p>
<ol>
<li>所有的文章</li>
<li>一个包含已选中文章Id的数组</li>
</ol>
<p>那么目前看来，单纯用redux来解决的话大概有两个解决方案：</p>
<ol>
<li><p>在state tree上新增加一个数组，里面包含所有被选中的文章（不是只有文章Id），然后把这个属性绑在post_list上。<br>这样一来我们需要重写post_selectors.js这个组件，在选中或者反选时调用一个新的action creator，而这个action<br>creator的作用就是根据参数传入的Id来对所有文章的数组进行过滤，把Id为参数传入的那个文章作为payload传给reducer，<br>最后reducer把那个文章加入到新书组内并且返回新的数组。</p>
</li>
<li><p>在post_list的componentWillMount时对所有文章的数组进行过滤，只保留Id包含在被选文章Id数组内的文章，然后对<br>其进行渲染。</p>
</li>
</ol>
<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>这两种解决办法都有一定的问题，第一种做法使得逻辑变得复杂，因为要在state上加入新的属性，并且需要加入新的<br>action creator以及reducer。第二种方法虽然看似简单，但是却使得组件的复用性变差了，如果我之后想做一个新的post_list<br>里面只显示没有选中的文章，那么就没办法服用这个组件，因为componentWillMount方法的逻辑不同。</p>
<h2 id="4-解决方案"><a href="#4-解决方案" class="headerlink" title="4. 解决方案"></a>4. 解决方案</h2><p>在redux生态系统中，有这么个东西，叫做reselect，<a href="https://github.com/reactjs/reselect" target="_blank" rel="external">GitHub 连接</a>，这个<br>模块能很好的解决我们目前的问题。首先，我们知道post_list上需要的文章并不是新的文章，而是由所有文章和已选中文章Id的<br>数组进行过滤后得到的。如果state tree上的某个属性是由其他属性进行某种逻辑运算后得到的，那么我们就可以考虑使用reselect。</p>
<h3 id="使用reselect"><a href="#使用reselect" class="headerlink" title="使用reselect"></a>使用reselect</h3><p>首先为了让文件目录更清晰，我们在根目录下新增加一个文件夹，叫selectors用来存放所有的selector，至于selector是什么，<br>我们马上就知道了，目前的文件目录大概是这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">|- actions/</span><br><span class="line">|--- types.js  //存放所有action.type</span><br><span class="line">|--- index.js   //action creators</span><br><span class="line">|- components/</span><br><span class="line">|- selectors/   //包含所有selector</span><br><span class="line">|--- select_post_selector.js    //负责生成被选中的文章</span><br><span class="line">|--- app.js    //入口组件</span><br><span class="line">|--- containers/</span><br><span class="line">|------ post_list.js //显示已被选中的文章</span><br><span class="line">|------ post_selectors.js    //所有文章，点击checkbox会加入被选中的文章列表</span><br><span class="line">|- reducers/</span><br><span class="line">|--- all_post_reducer.js  //返回所有文章</span><br><span class="line">|--- index.js     //combinedReducer</span><br><span class="line">|--- select_post_reducer.js   //返回被选中或者被反选的文章</span><br><span class="line">|-index.js  //主入口</span><br></pre></td></tr></table></figure>
<p><strong> /selectors/select_post_selector.js </strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import &#123; createSelector &#125; from &apos;reselect&apos;;</span><br><span class="line"></span><br><span class="line">const allPostSelector = state =&gt; state.posts;</span><br><span class="line">const selectedIdSelector = state =&gt; state.selectedIds;</span><br><span class="line"></span><br><span class="line">const getSelectedPosts = (posts, selectedIds) =&gt; &#123;</span><br><span class="line">    return posts.filter(post =&gt; selectedIds.includes(post.id));</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">export default createSelector(allPostSelector, selectedIdSelector, getSelectedPosts);</span><br></pre></td></tr></table></figure></p>
<p>大概说一下，allPostSelector一个函数，它会在state tree上找到posts这个属性，也就是所有文章的数组，<br>selectedIdSelector和allPostSelector类似，会在state tree上找到selectedIds属性，也就是那个<br>包含所有被选文章Id的数组。</p>
<p>getSelectedPosts也是一个函数，它接收多个参数，然后返回根据这些参数生成的新属性，这个属性最后会绑定<br>到state tree上。</p>
<p>然后我们需要在post_list这一组件中使用这个用reselect生成的新属性<br><strong> /components/containers/post_list.js </strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123; Component &#125; from &apos;react&apos;;</span><br><span class="line">import &#123; connect &#125; from &apos;react-redux&apos;;</span><br><span class="line"></span><br><span class="line">import PostSelector from &apos;../../selectors/select_post_selector&apos;;</span><br><span class="line"></span><br><span class="line">class PostList extends Component &#123;</span><br><span class="line"></span><br><span class="line">    renderPostLists()&#123;</span><br><span class="line">        return this.props.selectedPosts.map(post=&gt;&#123;</span><br><span class="line">            return (</span><br><span class="line">                &lt;li className=&quot;list-group-item&quot; key=&#123;post.id&#125;&gt;&#123;post.title&#125;&lt;/li&gt;</span><br><span class="line">            )</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    render()&#123;</span><br><span class="line">        return (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;h2&gt;已选中的文章&lt;/h2&gt;</span><br><span class="line">                &lt;ul className=&quot;list-group&quot;&gt;</span><br><span class="line">                    &#123;this.renderPostLists()&#125;</span><br><span class="line">                &lt;/ul&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function mapStateToProps(state)&#123;</span><br><span class="line">    return &#123;</span><br><span class="line">        selectedPosts: PostSelector(state)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default connect(mapStateToProps)(PostList);</span><br></pre></td></tr></table></figure></p>
<p>这个组件其实基本和使用redux对state进行绑定后的Smart组件没什么区别，唯一一点值得<br>注意的是第30行，<code>selectedPosts: PostSelector(state)</code>这里。我们只是用刚才写好<br>的selector对state进行加工，用已有的属性（所有post和被选postId）来生成这个新的属性。</p>
<h2 id="5-小结"><a href="#5-小结" class="headerlink" title="5. 小结"></a>5. 小结</h2><p>运行一下，一切都没问题，而且这样一来，post_list这个组件也可以很好的复用了。值得注意的<br>是，现在这个小例子只是为了向大家简单介绍一下reselect这个模块，或许你感觉不到使用reselect<br>的必要性，但是，要知道这个例子中的state tree结构非常简单，但是当在实际开发中，业务逻辑往往<br>会变得十分复杂，这也就导致了state tree结构也会变得复杂，通过这种方式来简化state tree将会<br>是一种非常好的优化手段。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[浅谈React Router中的browserHistory和hashHistory]]></title>
      <url>http://yoursite.com/ciqfij0m20007lcwzcy54rrep/</url>
      <content type="html"><![CDATA[<h2 id="React-Router简述"><a href="#React-Router简述" class="headerlink" title="React Router简述"></a>React Router简述</h2><p>React router，即路由，是react生态系统中一个重要的组成部分。它可以使单页应用具有类似于多页应用的<br>路由系统，即前端路由。绝对多数教程中对于Router History中的browserHisotry和hashHistory都是<br>一笔带过：不要用hashHistory，用brwoserHistory，其实在开发中，并没有那么简单，hashhistory有着<br>一定的应用场景，而browserHistory也会有几个坑。</p>
<a id="more"></a>
<h2 id="1-hashHistory-vs-browserHistory"><a href="#1-hashHistory-vs-browserHistory" class="headerlink" title="1. hashHistory vs browserHistory"></a>1. hashHistory vs browserHistory</h2><p>现在，有这么一个简单的小例子：</p>
<p>index.js:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">import React from &apos;react&apos;;</span><br><span class="line">import ReactDOM from &apos;react-dom&apos;;</span><br><span class="line">import &#123; Provider &#125; from &apos;react-redux&apos;;</span><br><span class="line">import &#123; createStore, applyMiddleware &#125; from &apos;redux&apos;;</span><br><span class="line">import &#123; Router, Route, browserHistory, hashHistory&#125; from &apos;react-router&apos;;</span><br><span class="line"></span><br><span class="line">import App from &apos;./components/app&apos;;</span><br><span class="line">import reducers from &apos;./reducers&apos;;</span><br><span class="line">import User from &apos;./components/user&apos;;</span><br><span class="line"></span><br><span class="line">const createStoreWithMiddleware = applyMiddleware()(createStore);</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;Provider store=&#123;createStoreWithMiddleware(reducers)&#125;&gt;</span><br><span class="line">    &lt;Router history=&#123;hashHistory&#125;&gt;</span><br><span class="line">        &lt;Route path=&quot;/&quot; component=&#123;App&#125; &gt;</span><br><span class="line">            &lt;Route path=&quot;user&quot; component=&#123;User&#125; /&gt;</span><br><span class="line">        &lt;/Route&gt;</span><br><span class="line">    &lt;/Router&gt;</span><br><span class="line">  &lt;/Provider&gt;</span><br><span class="line">  , document.querySelector(&apos;.container&apos;));</span><br><span class="line">  </span><br></pre></td></tr></table></figure></p>
<p>app.js:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123; Component &#125; from &apos;react&apos;;</span><br><span class="line">import &#123; Link &#125; from &apos;react-router&apos;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">export default class App extends Component &#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;Link to=&quot;user&quot;&gt;&lt;h2&gt;User&lt;/h2&gt;&lt;/Link&gt;</span><br><span class="line">        &#123;this.props.children&#125;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p>user.js:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123; Component &#125; from &apos;react&apos;;</span><br><span class="line"></span><br><span class="line">export default class User extends Component &#123;</span><br><span class="line">    render()&#123;</span><br><span class="line">        return (</span><br><span class="line">            &lt;h3&gt;User Component&lt;/h3&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="在webpack-dev-server下的运行效果大概是这样："><a href="#在webpack-dev-server下的运行效果大概是这样：" class="headerlink" title="在webpack-dev server下的运行效果大概是这样："></a>在webpack-dev server下的运行效果大概是这样：</h3><p>/<br><img src="/ciqfij0m20007lcwzcy54rrep/home_hash.png" alt="home_hash.png" title=""></p>
<p>/user<br><img src="/ciqfij0m20007lcwzcy54rrep/user_hash.png" alt="user_hash.png" title=""></p>
<p>注意到地址栏里那一串奇怪的字符串了么（?_k=jgh8bl），这是hashHistory为我们自动添加的，<br>而且，当我们访问/user时，路径也很奇怪。</p>
<h3 id="接下来我们来试着把history-hashHistory-换成history-browserHistory-试试，"><a href="#接下来我们来试着把history-hashHistory-换成history-browserHistory-试试，" class="headerlink" title="接下来我们来试着把history = {hashHistory}换成history = {browserHistory}试试，"></a>接下来我们来试着把<code>history = {hashHistory}</code>换成<code>history = {browserHistory}</code>试试，</h3><p>/<br><img src="/ciqfij0m20007lcwzcy54rrep/home_browser.png" alt="home_browser.png" title=""></p>
<p>/user<br><img src="/ciqfij0m20007lcwzcy54rrep/user_browser.png" alt="user_browser.png" title=""></p>
<p><em>注意，这里有个小坑，在webpack.config.js中，我们需要在devServer里面加一个</em><br><em><code>historyApiFallback: true</code>的配置项，这一点大家应该都知道，所以就不赘述了。</em></p>
<p>嗯，这次地址栏清爽多了，没有奇怪的字符串，一切都正常了。似乎browserHistory这种<br>方式明显比hashHistory好很多。但是，这里要说一下，如果我们有意不希望用户直接通过<br>地址栏访问user路由的话，就可以使用hashHistory。</p>
<h2 id="2-生产环境"><a href="#2-生产环境" class="headerlink" title="2.生产环境"></a>2.生产环境</h2><p>假如现在项目写完了，需要部署到生产环境下，那么webpack-devserver就不能用了。现在<br>我们需要做两件事：1.写个简单的node服务器，2.用webpack对项目进行打包，生成bundle.js</p>
<h3 id="1-node服务器"><a href="#1-node服务器" class="headerlink" title="1. node服务器"></a>1. node服务器</h3><p>因为整个项目只需要index.html和bundle.js这两个文件，所以我们可以写个简单的静态<br>服务器，这里，我们用express来写，几行代码就能搞定。</p>
<p>server.js:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const express = require(&apos;express&apos;);</span><br><span class="line">const path = require(&apos;path&apos;);</span><br><span class="line"></span><br><span class="line">const app = express();</span><br><span class="line"></span><br><span class="line">app.use(express.static(__dirname));</span><br><span class="line"></span><br><span class="line">app.listen(8080);</span><br></pre></td></tr></table></figure>
<p>当浏览器访问/的时候，服务器就会默认发送index.js给浏览器，由于这个机制的存在，我们不用<br>配置任何路由，注意，这里的路由说的不是前端路由。</p>
<h3 id="2-webpack打包"><a href="#2-webpack打包" class="headerlink" title="2. webpack打包"></a>2. webpack打包</h3><p>webpack.config.js:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">  entry: [</span><br><span class="line">    &apos;./src/index.js&apos;</span><br><span class="line">  ],</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: __dirname,</span><br><span class="line">    publicPath: &apos;/&apos;,</span><br><span class="line">    filename: &apos;bundle.js&apos;</span><br><span class="line">  &#125;,</span><br><span class="line">  module: &#123;</span><br><span class="line">    loaders: [&#123;</span><br><span class="line">      exclude: /node_modules/,</span><br><span class="line">      loader: &apos;babel&apos;,</span><br><span class="line">      query: &#123;</span><br><span class="line">        presets: [&apos;react&apos;, &apos;es2015&apos;, &apos;stage-1&apos;]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;]</span><br><span class="line">  &#125;,</span><br><span class="line">  resolve: &#123;</span><br><span class="line">    extensions: [&apos;&apos;, &apos;.js&apos;, &apos;.jsx&apos;]</span><br><span class="line">  &#125;,</span><br><span class="line">  devServer: &#123;</span><br><span class="line">    historyApiFallback: true,</span><br><span class="line">    contentBase: &apos;./&apos;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在跟路径下打开命令行里输入<code>webpack -p</code>就会生成一个打包好的文件，我们给它起名为bundle.js。<br>现在把webpack-devserver停掉，然后运行server.js，<code>node server.js</code>，之后访问server<br>指定的端口（8080）应该就会看到正常的页面了。</p>
<p>/<br><img src="/ciqfij0m20007lcwzcy54rrep/home_browser.png" alt="home_browser.png" title=""></p>
<p>/user<br><img src="/ciqfij0m20007lcwzcy54rrep/user_browser.png" alt="user_browser.png" title=""></p>
<p>貌似一切都OK了，但是，当我们在/user下刷新一下时就不太OK了。。。<br>/user<br><img src="/ciqfij0m20007lcwzcy54rrep/user_error.png" alt="user_error.png" title=""></p>
<p>页面中显示的”Cannot GET user”是express给我们响应回来的内容，并不是我们刚才写的user.js，<br>也就是说，浏览器并没有使用我们react-router中给出的路由。</p>
<p>其实原因很简单，因为react-router中的路由实际上是前端路由，并不是真正意义上的路由。说白了，<br>不管你请求什么地址，前端路由都不会让浏览器向服务器发送请求，而是在前端直接做处理，然后给用户<br>看相应的页面，也就是说，无论用户请求什么路径，其实用户一直都是在index页面上。</p>
<p>这一点我们同样可以在浏览器的console里的Network中得到证实，理论上，当我们点击user链接或者在<br>浏览器中手动切换到/user时，浏览器并没有向服务器请求新的页面。但是，当我们真的部署到生产环境时，<br>在浏览器手动切换/user或者刷新时，浏览器并不知道我们其实是想让前端路由来做处理并且不发送请求给<br>服务器的，所以依然会发请求给服务器，请求/user，然后服务器没有相关的配置，所以就返回一个默认的<br>404页面给浏览器。</p>
<p>如果我们这里使用的是hashHistory，就不会有这个问题，因为hashHistory在路径后面加了一个#符号，<br>这就相当于告诉浏览器不要向服务器发请求。</p>
<h3 id="3-改进server-js"><a href="#3-改进server-js" class="headerlink" title="3. 改进server.js"></a>3. 改进server.js</h3><p>这里我们如果仍然想使用browserHistory的话，就要对服务器端进行改进，其实做法很简单，就是添加一个<br>匹配所有路径的配置，然后让这个配置返回index.html，也就是说无论浏览器请求什么路径，都会返回index.html<br>然后浏览器的前端路由（react-router）就能开始工作了。</p>
<p>server.js:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">const express = require(&apos;express&apos;);</span><br><span class="line">const path = require(&apos;path&apos;);</span><br><span class="line"></span><br><span class="line">const app = express();</span><br><span class="line"></span><br><span class="line">app.use(express.static(__dirname));</span><br><span class="line"></span><br><span class="line">app.get(&apos;*&apos;, (req, res)=&gt;&#123;</span><br><span class="line">    res.sendFile(path.resolve(__dirname, &apos;index.html&apos;));</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.listen(8080);</span><br></pre></td></tr></table></figure>
<p>然后重启服务器，一切就正常了，而且没有向在切换到/user时向服务器发送新的请求，这说明前端路由也能正常<br>工作了。而且，当我们访问一个不存在的路径时，比如(/abcde)，服务器也没有显示默认的<code>Cannot GET</code>页面<br>而是在控制台里报了个warning，说不能找到相应的路径。</p>
<h3 id="4-关于其他路径"><a href="#4-关于其他路径" class="headerlink" title="4. 关于其他路径"></a>4. 关于其他路径</h3><p>也许会有同学问，如果我的服务器还配置了一套API在/api路径下，那么这套API是不是就不能用了。答案是不会。<br>但是我们要把这些配置写在<code>app.get(&#39;*&#39;)</code>之前。因为express是按照配置的顺序来对请求进行匹配的，如果写<br>在<code>app.get(&#39;*&#39;)</code>之后，就会先匹配到/*，因为成功匹配上了，就会返回index.html。</p>
<p>server.js:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">const express = require(&apos;express&apos;);</span><br><span class="line">const path = require(&apos;path&apos;);</span><br><span class="line"></span><br><span class="line">const app = express();</span><br><span class="line"></span><br><span class="line">app.use(express.static(__dirname));</span><br><span class="line"></span><br><span class="line">app.get(&apos;/api&apos;, (req, res)=&gt;&#123;</span><br><span class="line">    res.json(&#123;username: &apos;abc&apos;&#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.get(&apos;*&apos;, (req, res)=&gt;&#123;</span><br><span class="line">    res.sendFile(path.resolve(__dirname, &apos;index.html&apos;));</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.listen(8080);</span><br></pre></td></tr></table></figure>
<p>这时我们访问/和/user时，一切正常，并且当我们访问/api时，也可以得到相应的内容。</p>
<p>/api<br><img src="/ciqfij0m20007lcwzcy54rrep/api_img.png" alt="api_img.png" title=""></p>
<h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h2><p>我们简略的分析了一下browserHistory和hashHistory的一些区别，并且做了个简单的<br>生产环境部署，以及踩了browserHistory在生产环境下的一个小坑。总的来说，一般情况<br>下我们都会选用在地址栏显示清爽的browserHistory，但是在一些情况下，hashHistory<br>也有者它的好处。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Node中的事件系统]]></title>
      <url>http://yoursite.com/ciqfij0lq0001lcwzp35rawlx/</url>
      <content type="html"><![CDATA[<h2 id="Node中的事件发布与订阅"><a href="#Node中的事件发布与订阅" class="headerlink" title="Node中的事件发布与订阅"></a>Node中的事件发布与订阅</h2><p>事件的发布和订阅系统(event)是NodeJS中的一个极为重要的系统，但是这个系统对于很多刚入坑的小伙伴来说可能难以理解，<br>这篇博客会为刚入坑的小伙伴们简单介绍一下事件（event），并且一步一步的写一个“山寨版”的事件系统。</p>
<a id="more"></a>
<h3 id="1-什么是事件系统"><a href="#1-什么是事件系统" class="headerlink" title="1. 什么是事件系统"></a>1. 什么是事件系统</h3><p>事件系统其实就是NodeJS中的一个模块（Events），这个模块使得NodeJS具有对事件的监听和触发的动能。<br>比如说，我们可以制定一个机制，一旦一个文件读取完毕，我们会做什么事情，比如将文件内容打印出来或者进行修改。<br>事件系统是NodeJS中的一个极其重要的系统，因为Javascript语言原本是前端的脚本语言，对于这种事件机制支持<br>比较弱，而这种机制又是后端语言必备的，所以NodeJS实现了一套很完善的事件系统。许多初识Node的同学可能<br>会觉得事件机制比较难理解，但其实真没有那么难。</p>
<h3 id="2-如何使用事件系统"><a href="#2-如何使用事件系统" class="headerlink" title="2. 如何使用事件系统"></a>2. 如何使用事件系统</h3><p>在NodeJS中有个模块叫做Events，它的作用就是让我们很容易的去使用事件。</p>
<ol>
<li><p>首先，要导入events模块。由于这个模块是一个构造函数，所以我们需要new一个event实例。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var Events = require(&apos;events&apos;);</span><br><span class="line"></span><br><span class="line">var myEvent = new Events();</span><br></pre></td></tr></table></figure>
</li>
<li><p>在这个实例的原型上有很多方法，这里只说两个最简单的，其他的可以在<a href="https://nodejs.org/dist/latest-v6.x/docs/api/events.html" target="_blank" rel="external">NodeJS的官方API</a>上面看到。<br><em>on</em>方法负责定义事件并且绑定到一个监听者（listener）上，就像这样</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">myEvent.on(&apos;hello&apos;, function()&#123;</span><br><span class="line">    console.log(&apos;hello back&apos;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>这里，我们定义了一个名为hello的事件，而监听者一旦发现这个事件被触发了，就会执行function里面的内容。</p>
</li>
<li><p>一个事件上可以绑定多个监听者，所以我们再为这个名为hello的事件绑定一个吧</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">myEvent.on(&apos;hello&apos;, function()&#123;</span><br><span class="line">    console.log(&apos;Ignored&apos;)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>事件绑定好了，我们来触发一下这个事件，看看我们绑定的监听者会不会生效，然而触发事件我们<br>只需要调用它的emit方法就可以了，就像这样</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myEvent.emit(&apos;hello&apos;);</span><br></pre></td></tr></table></figure>
<p>执行的结果如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hello back</span><br><span class="line">Ignored</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="3-自己写一个山寨版的事件系统"><a href="#3-自己写一个山寨版的事件系统" class="headerlink" title="3.自己写一个山寨版的事件系统"></a>3.自己写一个山寨版的事件系统</h3><p>在学习编程中有一个很好的方法，就是 “山寨”，或者发明轮子，其实就是通过实现一个已经有的功能来加深对这个<br>功能的理解，那么我们也来“山寨”一个最简单的事件系统吧，来看看事件到底是个什么东西。</p>
<ol>
<li><p>首先，我们知道了NodeJS的事件模块是个构造函数，所以我们也来写一个构造函数。这里我们给一个空对象，这个对象会<br>用来存放各类的事件（event），比如之前我们用过的hello事件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function Events()&#123;</span><br><span class="line">    this.events = &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>刚才我们一共使用了两个方法，on和emit对吧，这里我们也要在原型上扩展这两个方法，以达到让“山寨版”可以像“正版”一样工作。<br>首先on可以接受两个参数，一个是事件的名字（hello），另一个是事件触发时需要执行的方法，而emit只需要接受一个事件名就可以了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Events.prototype.on = function(type, responseFunction)&#123;</span><br><span class="line">  </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Events.prototype.emit = function(type)&#123;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>想想当on方法执行时发生了什么，它把一个方法绑定到一个事件上了，所以大概是这样的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Events.prototype.on = function(type, responseFunction)&#123;</span><br><span class="line">    this.events[type] = responseFunction;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这里说明一下，在</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function Events()&#123;</span><br><span class="line">    this.events = &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>中，this.events这个object大概会是一个这样的结构，每个受到绑定的事件都会对应相应的方法，就像这样</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    hello: function()&#123;...&#125;,</span><br><span class="line">    fileLoaded: function()&#123;...&#125;,</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>比如，当hello被触发时，里面的function就会执行。</p>
</li>
<li><p>同理，我们再来想想当调用了emit方法时发生了什么，对，事件对应的方法被执行了，所以大概会是这样，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Events.prototype.emit = function(type)&#123;</span><br><span class="line">    this.events[type]();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>注意，这里说明一下，我们调用某个object上的一个方法或者访问这个object上的某个属性时，可以通过两种方法：<br>一是通过打点的方法，比如<code>obj.xxx</code>（属性），<code>obj.xxx()</code>（方法）；<br>二是通过方括号的方法，比如<code>obj[&#39;xxx&#39;]</code>（属性），<code>obj[&#39;xxx&#39;]()</code>（方法）。<br>但是这里我们只能用后者，因为我们不是要调用this.events的type属性而是要调用通过type传进来的那个属性，<br>换句话说，type是个变量，它的值才是我们真正要调用的，比如events.hello。</p>
</li>
<li><p>好了，这样就差不多了。哦，对了！一会别的文件要引用这个模块，所以我们要导出一下，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">module.exports = Events;</span><br></pre></td></tr></table></figure>
</li>
<li><p>来执行一下吧，把刚才的<code>require(&#39;events&#39;)</code>换成我们的“山寨版”吧<code>require(&#39;./modules/myEvents&#39;)</code>，<br>走起！！！<br>输出：<br><code>Ignored</code><br>Yeah！！！<br>等等，好像哪里不对啊，刚才明明绑定了两个监听者现在怎么只输出了一个啊？这什么情况。。。</p>
</li>
</ol>
<h3 id="3-山寨版改造"><a href="#3-山寨版改造" class="headerlink" title="3.山寨版改造"></a>3.山寨版改造</h3><ol>
<li><p>通过分析刚才我们写的代码，很明显，每次我们调用on方法时，会给event实例重新赋值，换句话说，之后的会覆盖之前的，<br>所以要让我们的“山寨版具有和”正版一样对一个事件多次绑定的功能，我们需要用一个集合来存放同一事件绑定的所有监听者，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Events.prototype.on = function(type, responseFunction)&#123;</span><br><span class="line">    if(this.events[type])&#123;</span><br><span class="line">        this.events[type].push(responseFunction);</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        this.events[type] = [];</span><br><span class="line">        this.events[type].push(responseFunction);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这里的逻辑是，如果一个事件（event）之前已经定义过了，那我们就直接在这个事件所对应的监听者数组里push新绑定的方法，<br>如果没有定义过，那么就定义一个空监听者数组，然后把对应的方法push进去。说白了，第一次我们绑定hello这个事件的时候，<br>实例的events上并没有这个叫hello的属性，那么我们定义一个数组，然后把hello对应的方法push进去，第二次我们发现已经<br>有hello了，就在相应的数组里push一个新的方法。hello这个事件大概是这样的<br>第一次：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//on执行前</span><br><span class="line">events:&#123;&#125;</span><br><span class="line">//on执行后</span><br><span class="line">events:&#123;</span><br><span class="line">    hello: [function()&#123;...&#125;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第二次</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//on执行前</span><br><span class="line">events:&#123;</span><br><span class="line">    hello: [function()&#123;...&#125;]</span><br><span class="line">&#125;</span><br><span class="line">//on执行后</span><br><span class="line">events:&#123;</span><br><span class="line">    hello: [function()&#123;...&#125;, function()&#123;...&#125;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以对这段代码进行一下简化，说白了就是想少写点字</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Events.prototype.on = function(type, responseFunction)&#123;</span><br><span class="line">    this.events[type] = this.events[type] || [];</span><br><span class="line">    this.events[type].push(responseFunction);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>OK，on这个方法就大概写完了。</p>
</li>
<li><p>既然events.hello已经是一个包含了多个function的数组，所以我们不能像之前那样<br><code>this.events[type]();</code>简单粗暴的直接调用了，我们需要执行数组里的每一个function，也就是<br>对这个数组进行一下遍历，这里有很多种方法，我们用forEach，因为效率比较高。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Events.prototype.emit = function(type)&#123;</span><br><span class="line">    this.events[type].forEach(function(responseFunc)&#123;</span><br><span class="line">        responseFunc();</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>好了，到这里这个“山寨版”也就差不多完成了，我们来跑跑吧：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hello back</span><br><span class="line">Ignored</span><br></pre></td></tr></table></figure>
<p>非常好！这样我们的“山寨版”也能绑定多个监听者了。</p>
</li>
</ol>
<p>完整代码如下<br>./modules/myEvents.js<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function Events()&#123;</span><br><span class="line">    this.events = &#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Events.prototype.on = function(type, responseFunction)&#123;</span><br><span class="line">    this.events[type] = this.events[type] || [];</span><br><span class="line">    this.events[type].push(responseFunction);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Events.prototype.emit = function(type)&#123;</span><br><span class="line">    this.events[type].forEach(function(responseFunc)&#123;</span><br><span class="line">        responseFunc();</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">module.exports = Events;</span><br></pre></td></tr></table></figure></p>
<p>./app.js<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var Events = require(&apos;./modules/myEvents&apos;);</span><br><span class="line"></span><br><span class="line">var myEvent = new Events();</span><br><span class="line"></span><br><span class="line">myEvent.on(&apos;hello&apos;, function()&#123;</span><br><span class="line">    console.log(&apos;hello back&apos;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">myEvent.on(&apos;hello&apos;, function()&#123;</span><br><span class="line">    console.log(&apos;Ignored&apos;)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">myEvent.emit(&apos;hello&apos;);</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<h3 id="4-总结"><a href="#4-总结" class="headerlink" title="4.总结"></a>4.总结</h3><p>我们写了一个“山寨版”的事件绑定和发布系统，但是山寨毕竟是山寨，我们看看NodeJS源码中的Events模块。。。<br><strong>我滴神呐。。。同样是程序猿，代码的差距咋就这么大捏。。。</strong><br>那是当然，人家的代码有很多我们没有的方法，而且人家有很多异常处理等等。但是如果你仔细看正版的on和emit方法<br>会发现其实他们实现的方法和我们的差不太多，那是当然，我是看过源码才。。。我是说。。。我是受到了源码的启发<br>才写的这篇博客。</p>
<h3 id="5-参考资料"><a href="#5-参考资料" class="headerlink" title="5.参考资料"></a>5.参考资料</h3><ol>
<li><a href="https://nodejs.org/dist/latest-v6.x/docs/api/events.html" target="_blank" rel="external">官方文档</a></li>
<li><a href="https://github.com/nodejs/node" target="_blank" rel="external">NodeJS源码</a></li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Node中的module和require]]></title>
      <url>http://yoursite.com/ciqfij0m00006lcwz5vp9ak3n/</url>
      <content type="html"><![CDATA[<h2 id="Node中的模块"><a href="#Node中的模块" class="headerlink" title="Node中的模块"></a>Node中的模块</h2><p>在Node中，很大的一个组成部分就是模块，其中有Node中的core模块，有从npm上下载的第三方模块以及我们自己写的模块。<br>NodeJS在模块化方面使用的是exports和require来导入和导出。</p>
<a id="more"></a>
<p>这里我写了几个小例子来和大家分享一下exports的几种简单方法。文件目录大概是这样</p>
<img src="/ciqfij0m00006lcwz5vp9ak3n/module_example.png" alt="module_example.png" title="">
<h3 id="1-直接导出"><a href="#1-直接导出" class="headerlink" title="1.直接导出"></a>1.直接导出</h3><p> ./modules/hello1.js<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">module.exports = function()&#123;</span><br><span class="line">    console.log(&apos;hello world 1&apos;)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>这是一种很简单的到处方法，module.expots可以理解成是一个空对象（{}），而导出的方法就是直接用自己写好的function或者<br>object来替换这个对象。</p>
<p> ./app.js<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var hello1 = require(&apos;./modules/hello1&apos;);</span><br><span class="line">hello1();</span><br></pre></td></tr></table></figure></p>
<h3 id="2-作为exports的一个属性导出"><a href="#2-作为exports的一个属性导出" class="headerlink" title="2.作为exports的一个属性导出"></a>2.作为exports的一个属性导出</h3><p> ./modules/hello2.js<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var hello = function()&#123;</span><br><span class="line">    console.log(&apos;hello world 2&apos;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">module.exports.hello = hello;</span><br></pre></td></tr></table></figure><br>为module.exports增加一个名为hello的属性</p>
<p> ./app.js<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var hello2 = require(&apos;./modules/hello2&apos;);</span><br><span class="line">hello2.hello();</span><br></pre></td></tr></table></figure></p>
<h3 id="3-用一个实例来替换module-exports"><a href="#3-用一个实例来替换module-exports" class="headerlink" title="3. 用一个实例来替换module.exports"></a>3. 用一个实例来替换module.exports</h3><p> ./modules/hello3.js<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var hello3 = function()&#123;</span><br><span class="line">    this.word = &apos;hello world 3&apos;;</span><br><span class="line">    this.hello = function()&#123;</span><br><span class="line">        console.log(this.word)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">module.exports = new hello3();</span><br></pre></td></tr></table></figure><br>这里可以看到，首先我们写一个构造函数用来生成实例，然后把一个新生成的实例赋给module.exports，就像这样：</p>
<p> ./app.js<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var hello3a = require(&apos;./modules/hello3&apos;);</span><br><span class="line">hello3a.hello();</span><br></pre></td></tr></table></figure><br>但是，如果我们改变hello3a的属性会怎么样呢？按理说实例都是各自独立的，hello3a的属性改变了应该不会影响其他的实例啊，<br>让我们来做个实验吧</p>
<ul>
<li>./app.js<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var hello3a = require(&apos;./modules/hello3&apos;);</span><br><span class="line">hello3a.hello();</span><br><span class="line">//这里word属性已经改变了</span><br><span class="line">hello3a.word = &apos;Good bye&apos;;</span><br><span class="line"></span><br><span class="line">var hello3b = require(&apos;./modules/hello3&apos;);</span><br><span class="line">hello3b.hello();</span><br><span class="line"></span><br><span class="line">//输出是这样的</span><br><span class="line">//hello world 3</span><br><span class="line">//Good bye</span><br></pre></td></tr></table></figure>
为什么啊？！我不是只改变了hello3a的word属性吗，为什么hello3b也会受到影响？！<br>其实，module.exports是有缓存机制的，只要一个模块生成了一次，之后所有对这个模块的require都会判断是否存在这个模块的缓存，<br>如果有，就会返回这份缓存。也就是说，不管一个模块被require多少次，其实都是require的同一个模块。那么上面的例子我该怎么让这两个实例<br>真正的做到独立存在呢？</li>
</ul>
<h3 id="4-导出一个构造函数"><a href="#4-导出一个构造函数" class="headerlink" title="4. 导出一个构造函数"></a>4. 导出一个构造函数</h3><p> ./modules/hello4.js<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var HelloCreator = function()&#123;</span><br><span class="line">    this.word = &apos;hello world 4&apos;;</span><br><span class="line">    this.hello = function()&#123;</span><br><span class="line">        console.log(this.word);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">module.exports = HelloCreator;</span><br></pre></td></tr></table></figure><br>其实很简单，只要导出那个构造函数就行了，谁需要实例就去自己new吧</p>
<p> ./app.js<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var Hello = require(&apos;./modules/hello4&apos;);</span><br><span class="line">var hello4a = new Hello();</span><br><span class="line"></span><br><span class="line">hello4a.word = &apos;Good bye&apos;;</span><br><span class="line">hello4a.hello();</span><br><span class="line"></span><br><span class="line">var hello4b = new Hello();</span><br><span class="line">hello4b.hello();</span><br></pre></td></tr></table></figure><br>当然了，我们不能直接使用这个模块，因为它仅仅只是个构造函数，所以只要new一下就可以了。</p>
<h3 id="5-只把想要暴露的方法和属性暴露出去"><a href="#5-只把想要暴露的方法和属性暴露出去" class="headerlink" title="5. 只把想要暴露的方法和属性暴露出去"></a>5. 只把想要暴露的方法和属性暴露出去</h3><p> ./modules/hello5.js<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var word = &apos;Hello world 5&apos;;</span><br><span class="line">var word2 = &apos;Good bye&apos;;</span><br><span class="line"></span><br><span class="line">var hello = function()&#123;</span><br><span class="line">    console.log(word);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var bye = function()&#123;</span><br><span class="line">    console.log(word2);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">    hello: hello,</span><br><span class="line">    bye: bye</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>在这个例子里，我们只把hello和bye这两个方法暴露给外界，对于其他的属性和方法，外界是无法访问到的。这样做在某种意义上保证了隐秘数据不会被外界<br>访问到，而且还增加了模块的可控性。</p>
<p> ./app.js<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var hello5 = require(&apos;./modules/hello5&apos;);</span><br><span class="line">hello5.hello();</span><br><span class="line">hello5.bye();</span><br></pre></td></tr></table></figure></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>定义模块和获得模块的方法有很多，以上只是列举了几种比较常见的，希望能对新入坑的小伙伴们有所帮助。其实我认为没有哪种方法是绝对好或者绝对不好的<br>具体使用哪种方法写模块或者导出模块还是要看具体的业务需求。</p>
]]></content>
    </entry>
    
  
  
</search>
