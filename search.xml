<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[es6学习笔记之三 箭头函数]]></title>
      <url>http://yoursite.com/cir0xtdc700008gwzzd5e2ewn/</url>
      <content type="html"><![CDATA[<p>这篇学习笔记继续上一篇，为大家介绍es6给大家带来的一些实用功能，今天我们来简单说说箭头函数（=&gt;）。我个人<br>非常喜欢这个功能，因为它可以使代码变得更简单，更容易阅读，而且某些时候还可以为我们解决javascript的一个<br>很头疼的问题：this问题。</p>
<h2 id="1-一些题外话"><a href="#1-一些题外话" class="headerlink" title="1. 一些题外话"></a>1. 一些题外话</h2><p>我们都知道es6是近两年才开始普及的javascript版本，虽然目前的几大浏览器都开始支持es6，但是旧版本的浏览器<br>和一些其他平台上却没有办法支持es6，那是不是这意味着我们如果要从兼容性方面考虑的话，就不应该使用es6了呢？<br>并不是！因为有这么一款神器的工具叫babel，它可以将es6甚至是es7的一部分新语法转换成es5，让我们简单来看一下<br>babel的网站：英文版：<a href="http://babeljs.io/" target="_blank" rel="external">http://babeljs.io/</a>，中文版：<a href="http://babeljs.cn/" target="_blank" rel="external">http://babeljs.cn/</a><br>这里需要讲一下，我建议如果你决定使用es6的话，就一定要会用babel，而幸运的是，网上babel的教程非常多，而且<br>babel本身也不是很难上手。这里我们先进入babel中文网站，然后点击最上面的“在线实验”，你会看到有两个在线编辑器<br><img src="/cir0xtdc700008gwzzd5e2ewn/babel1.png" alt="babel1.png" title=""></p>
<p>我们可以在左边的编辑器里打入我们想测试的es6代码，右边就会输出babel转换以后的es5代码，我们可以用这种方法<br>了解babel是如何把我们的es6代码进行转换的，举例来说，我在左边输入<code>let a = &#39;hello world&#39;</code>，右边就会显<br>示出<code>var a = &#39;hello world&#39;</code>，是不是很方便。但是要注意的是，这个在线实验只是个“山寨版”，真正的babel比<br>它要强大的多，所以千万不要把写好的es6代码简单的复制，粘贴到这里，然后把转换出来的es5贴回去。如果想使用<br>babel，最好还是使用它的命令行工具，官网里面有详细的介绍。</p>
<h2 id="2-用箭头函数简化代码"><a href="#2-用箭头函数简化代码" class="headerlink" title="2. 用箭头函数简化代码"></a>2. 用箭头函数简化代码</h2><h3 id="2-1-初识箭头函数"><a href="#2-1-初识箭头函数" class="headerlink" title="2.1 初识箭头函数"></a>2.1 初识箭头函数</h3><p>我们先来写一个最最简单的加法function，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const double = function(a)&#123;</span><br><span class="line">    return a*2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(double(3)); //这里会输出6</span><br></pre></td></tr></table></figure><br>大家来看一下这个function，就算是这么简单的逻辑，我们还是一样要写function，return，各种大括号和小括号。是<br>不是感觉特别麻烦。这就是箭头函数存在的一个意义。我们来看一下箭头函数的版本应该怎么写：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const addition = (a)=&gt;&#123;</span><br><span class="line">    return a*2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(double(3)); //这里会输出6</span><br></pre></td></tr></table></figure>
<p>是不是感觉清爽了一点？其实这里只是刚开始，其实还没怎么开始简化。我们去掉function这个词，但后在参数后面加上一个<br>粗箭头（=&gt;），其实就是一个等于号加上一个大于号，就这么简单。其实它不仅仅省去了function这个单词，请仔细看箭头这<br>段代码，是不是感觉有点像函数式？箭头左边是输入，右边是输出，在这个例子里面，就是输入一个数，然后输出它的两倍。而<br>function本身不就是函数的意思么？这样是不是比<code>function(a){...}</code>更直观了呢？其实javascript里面有一个流派，<br>叫做函数式编程，这个流派会大量的使用这种函数式，让代码尽量符合输入=&gt;输出这种函数的理念，同时尽可能的少使用面向对<br>象的概念，代码变得更纯净并且更好预测（给你一个函数，相同的输入一定会产出相同的输出）。</p>
<h3 id="2-2-进一步简化"><a href="#2-2-进一步简化" class="headerlink" title="2.2 进一步简化"></a>2.2 进一步简化</h3><p>如果你并不关心所谓函数式编程，只是想简化代码，而且觉得仅仅这样还不过瘾的话，别着急，我们的代码其实还能继续简化，这<br>里说一下箭头函数的第二个简化规则：如果箭头右边的函数体只有一行代码并且需要return一个东西的话，那么我们可以去掉大括<br>号和return关键字，代码就变成了这样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const addition = (a)=&gt; a*2;</span><br><span class="line"></span><br><span class="line">console.log(double(3)); //这里会输出6</span><br></pre></td></tr></table></figure></p>
<p>对，就一行，更简洁了吧？这里再强调一下，你的代码体只有一行的时候，才能去掉大括号，如果多于一行，那么大括号和return<br>都必须保留。第二，如果你像上面一样，只写一行的话，那就意味着=&gt;右边是你要return的内容，并且一定会return。还没完<br>呢，箭头函数还有第三个简化规则，就是如果你函数的参数（arguments）只有一个的话，那么你可以去掉小括号，代码就变成<br>了这样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const addition = a=&gt; a*2;</span><br><span class="line"></span><br><span class="line">console.log(double(3)); //这里会输出6</span><br></pre></td></tr></table></figure><br>怎么样？这样够简洁了吧！原来的function{…}直接变成了一个算术式。</p>
<h2 id="3-用箭头函数改变this指针"><a href="#3-用箭头函数改变this指针" class="headerlink" title="3. 用箭头函数改变this指针"></a>3. 用箭头函数改变this指针</h2><p>还是照例先上一段代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const person = &#123;</span><br><span class="line">    name: &apos;John&apos;,</span><br><span class="line">    skills: [&apos;javascript&apos;, &apos;html&apos;, &apos;css&apos;],</span><br><span class="line">    sayHello: function()&#123;</span><br><span class="line">        return this.skills.forEach(function(skill)&#123;</span><br><span class="line">            console.log(this.name+&apos; knew &apos;+ skill);</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line">person.sayHello();</span><br></pre></td></tr></table></figure></p>
<p>这段代码很简单，就是我们定义了一个object，然后有name和skills两个属性，其中skills是一个数组，里面有三个字符串，<br>然后我们在这个object上面定义一个sayHello的方法，对于skills数组里的每一个skill输出一段话，这里可以看到，我们<br>用了之前说过的forEach方法对数组进行迭代。但是，在我们执行这段代码的时候，会发现输出结果是这样的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">knew javascript</span><br><span class="line">knew html</span><br><span class="line">knew css</span><br></pre></td></tr></table></figure><br><code>this.name</code>并没有输出，我们在<code>console.log(this.name+&#39; knew &#39;+ skill);</code>之前加上<code>console.log(this);</code>会<br>发现，this输出的是window或者global。这其实是因为forEach里面的那个function是回调函数，回调函数的this指向的是全<br>局上下文，在node环境里运行就是global，在浏览器运行就是window。</p>
<p>如果想让它正常的输出，我们通常会用这两种办法：</p>
<ol>
<li><p>bind改变this指针：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">const person = &#123;</span><br><span class="line">    name: &apos;John&apos;,</span><br><span class="line">    skills: [&apos;javascript&apos;, &apos;html&apos;, &apos;css&apos;],</span><br><span class="line">    sayHello: function()&#123;</span><br><span class="line">        return this.skills.forEach((function(skill)&#123;</span><br><span class="line">            console.log(this);</span><br><span class="line">            console.log(this.name+&apos; knew &apos;+ skill);</span><br><span class="line">        &#125;).bind(this))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>对this进行缓存：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const person = &#123;</span><br><span class="line">    name: &apos;John&apos;,</span><br><span class="line">    skills: [&apos;javascript&apos;, &apos;html&apos;, &apos;css&apos;],</span><br><span class="line">    sayHello: function()&#123;</span><br><span class="line">        var self = this;</span><br><span class="line">        return this.skills.forEach(function(skill)&#123;</span><br><span class="line">            console.log(self);</span><br><span class="line">            console.log(self.name+&apos; knew &apos;+ skill);</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>这两种方法我们应该都很熟悉吧。好，我们来改写一下sayHello这个方法，用箭头函数来代替function：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const person = &#123;</span><br><span class="line">    name: &apos;John&apos;,</span><br><span class="line">    sayHello: function()&#123;</span><br><span class="line">        return this.skills.forEach(skill=&gt;&#123;</span><br><span class="line">                    console.log(`$&#123;this.name&#125; knew $&#123;skill&#125;`);</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>当你用之前的<code>person.sayHello()</code>方法调用时，你会发现这个方法输出的是正确的，而且如果你试着在箭头函数里面输出<br>this时，发现它输出的是peron这个对象。这就是箭头函数的另一大特性，改变this指针，把this改变成这个function外面<br>一层的执行上下文。也可以这么理解，箭头函数不会创建独立的上下文，而是引用的外层的上下文。</p>
<p>我们再来看一个例子，这个例子证明了改变this指针未必总是好的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">const person = &#123;</span><br><span class="line">    name: &apos;john&apos;,</span><br><span class="line">    getName: function()&#123;</span><br><span class="line">        return this.name;</span><br><span class="line">    &#125;,</span><br><span class="line">    getNameArrow: ()=&gt;this.name</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">console.log(person.getName());//这里正常输出john</span><br><span class="line">console.log(person.getNameArrow());//这里无法输出</span><br></pre></td></tr></table></figure><br>getName和getNameArrow唯一的区别就是一个用了箭头函数，一个用了普通的function。而用了箭头函数的getNameArrow中<br>this指针指向的是外层上下文，也就是全局上下文，而全局上下文里面没有name这个属性，所以无法正常输出。</p>
<h2 id="4-适合与不适合用箭头函数的情况"><a href="#4-适合与不适合用箭头函数的情况" class="headerlink" title="4. 适合与不适合用箭头函数的情况"></a>4. 适合与不适合用箭头函数的情况</h2><p>从上面的例子，我们能看出来，不是所有时候都要用箭头函数的，这里我大概向大家介绍一下我一般会在什么时候用箭头函数，什么<br>时候舍弃箭头函数而用普通的function函数</p>
<p>1）回调函数中适合使用箭头函数。这样可以使代码变得更简洁，更容易理解，比如forEach，map这些方法都需要传入一个回调函数<br>这就是一个使用箭头函数的好机会。</p>
<p>2） 高阶函数适合使用箭头函数，我们来看个例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//这是不用箭头函数的写法</span><br><span class="line">const add = function(a)&#123;</span><br><span class="line">    return function(b)&#123;</span><br><span class="line">        return a+b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">console.log(add(2)(3));</span><br><span class="line"></span><br><span class="line">//这是使用箭头函数的写法</span><br><span class="line">const add = a=&gt;b=&gt;a+b;</span><br><span class="line">console.log(add(2)(3));</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>代码看着是不是简单了很多。</p>
<p>3）在涉及到this时，除非需要使用apply，call或者bind去改变this指针，否则尽量不要用箭头函数。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>今天和大家简单的介绍了一下es6的又一个新功能：箭头函数，为什么要使用箭头函数，以及使用箭头函数简化代码的几个规则，并且给<br>大家看了箭头函数的另外一个功能：改变this指针。并且简单聊了一下我个人什么时候会用箭头函数，什么时候不会用，希望大家在以后<br>的工作和学习中可以尽量去尝试使用箭头函数，这样既可以简化代码，又可以使代码变得更清晰。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[es6学习笔记之二 const，let和模版字符串]]></title>
      <url>http://yoursite.com/cir0xtdcm00058gwzz6s5l8ab/</url>
      <content type="html"><![CDATA[<p>这篇学习笔记依然是介绍es6的一些常用的新功能，这一篇会介绍两种新功能：1. const和let，2.模板字符串。之所以把这两个完全不相关的<br>概念放在一起是因为这两部分的内容不是很多，而且很容易理解。同时，我也会介绍一些其他es6相关的内容。</p>
<a id="more"></a>
<h2 id="1-一些概念"><a href="#1-一些概念" class="headerlink" title="1. 一些概念"></a>1. 一些概念</h2><p>在开始我们的正篇之前，有几个概念需要大家牢记。es6的新功能分为两类，一类是真正的新增功能，另一类叫做语法糖，这两类虽然在代码中没什<br>么区别，但是实际上却完全不一样。真正的新增功能是指一个功能在以前没有，从这个版本开始加入的，比如Set和Map，const和let等。与这些<br>功能相比，语法糖指的是其实某个功能在以前的版本已经有了，但是写法很不友好，很不科学，所以为我们设计了新的写法，比如class关键字，虽<br>然看起来好像和java或者其他面向对象的写法很像，但是js里的class内部实现仍然靠的是原型链继承，和一般的面向对象编程的实现不一样，这<br>一点请务必牢记。</p>
<h2 id="2-let和const"><a href="#2-let和const" class="headerlink" title="2.let和const"></a>2.let和const</h2><p>var关键字是javascript中定义函数的方法，要知道javascript在一开始设计的时候只是为了操作DOM，可是现在呢，javascript可以说无处<br>不在，我们有NodeJs，可以用javascript来编写服务器代码，或者react native，用javascript来写手机原生app，甚至是electron，可<br>以用来开发各平台的桌面应用。所以只有var这一种关键字定义函数明显已经不够用，而且var本身的设计也有缺陷，所以es6为我们带来了两种新的<br>关键字，作用就是用来取代var。</p>
<h3 id="2-1-let"><a href="#2-1-let" class="headerlink" title="2.1 let"></a>2.1 let</h3><p>let几乎和var一样，唯一的区别就是let支持块级作用域，而且同名的函数不能定义两次，比如我们可以这样<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var a = 1;</span><br><span class="line">var a = 2;</span><br></pre></td></tr></table></figure><br>但是我们不能这样，会报错<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let a = 1;</span><br><span class="line">let a = 2;</span><br></pre></td></tr></table></figure><br>这些区别也正是我们应该用let代替var的理由，所以在以后的代码中，我们应该尽可能的使用let。</p>
<h3 id="2-2-const"><a href="#2-2-const" class="headerlink" title="2.2 const"></a>2.2 const</h3><p>const的意思是常量，如果你接触过别的编程语言，对于这个概念一定不陌生，常量顾名思义就是不会变化的量，所以当我们确定一个变量在之后不会<br>被改变时，就要尽量使用const。这样做的好处是可以使代码逻辑更加清晰，如果你看到const，那么就应该意识到，这个变量在之后的使用过程中值<br>不会发生改变。一旦试图改变const就会报错</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const a = 1;</span><br><span class="line">a = 2; //这里会抛出异常</span><br></pre></td></tr></table></figure>
<p>但是值得注意的是，如果用const定义了一个对象，那么我们可以改变这个变量上的属性，甚至可以为其增加新的属性，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const person = &#123;name: &apos;john&apos;, age: 10&#125;</span><br><span class="line">person = &#123;name: &apos;jane&apos;, age: 8&#125;//这里会报错，因为试图直接改变对象</span><br><span class="line">person.name = &apos;jane&apos;; //不会报错</span><br><span class="line">person.gender = &apos;female&apos;//不会报错</span><br></pre></td></tr></table></figure>
<h2 id="3-模板字符串"><a href="#3-模板字符串" class="headerlink" title="3. 模板字符串"></a>3. 模板字符串</h2><p>模板字符串是es6给我们带来的一个非常方便的功能，它可以使我们的string中插入javascript函数或者表达式。这使得我们不需要再去拼接字符串，<br>从而使得代码更加简洁，逻辑更加清晰。我们来看个例子：</p>
<p>拼接字符串的写法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let firstName = &apos;Peter&apos;;</span><br><span class="line">let lastName = &apos;Doe&apos;;</span><br><span class="line"></span><br><span class="line">//现在我们需要输出 My name is Peter Doe</span><br><span class="line">console.log(&apos;My name is &apos;+firstName+&apos; &apos;+lastName);</span><br></pre></td></tr></table></figure></p>
<p>模板字符串写法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let firstName = &apos;Peter&apos;;</span><br><span class="line">let lastName = &apos;Doe&apos;;</span><br><span class="line"></span><br><span class="line">console.log(`My name is $&#123;firstName&#125; $&#123;lastName&#125;`);</span><br></pre></td></tr></table></figure></p>
<p>是不是很方便？这里大概说一下，我们用`来替代字符串中的’或者”，然后在需要引入变量或者表达式时把它们包在${}中，这样就搞定了。下面我们再来<br>看两个表达式的例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let number = 2;</span><br><span class="line"></span><br><span class="line">console.log(`Number X 2 is $&#123;number*2&#125;`);</span><br><span class="line"></span><br><span class="line">console.log(`Today is $&#123;new Date()&#125;`);</span><br></pre></td></tr></table></figure><br>但是值得注意的是，如果有大量的逻辑运算，那么请不要直接写到${}中，比如迭代或者if条件，这样会使代码变得不清晰。</p>
<p>这里我来介绍两个我用模板字符串比较多的情况，如果各位碰到这种情况，也可以考虑使用模板字符串。</p>
<p>1) 动态url，有的时候，我们写出一个url时，它其中的某个部分是变量，要等待我们执行了某些操作以后才能赋值，我觉的这就是一个使用模板字符串的<br>好时机，比如我们在点击一个按钮后会得到一个postId，那么我们就可以直接把这个postId放到模板字符串中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const url = `www.mycoolblog.com/post$&#123;postId&#125;`;</span><br></pre></td></tr></table></figure></p>
<p>2) 拼接sql数据库query，如果你用过php或者NodeJs，那么你一定能体会拼接query的痛苦，我们来看个简单的，如果用拼接字符串怎么写：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const query = &quot;select name, age, gender from users where userId=&apos;&quot;+userId+&apos;&quot; and userPassword=&apos;&quot;+userPassword+&quot;&apos;&quot;;</span><br></pre></td></tr></table></figure><br>怎么样，这个其实是最简单的查询，如果我们需要用到表连接或者其他的复杂逻辑，那么这个query就会变得异常复杂，而且我几乎可以肯定你会因为少了一个<br>‘或者”而导致代码报错。</p>
<p>我们再来看看用模板字符串可以怎么做：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const query = `select name, age, gender from users where userId=&apos;$&#123;userId&#125;&apos; and userPassword=&apos;$&#123;userPassword&#125;&apos;`;</span><br></pre></td></tr></table></figure><br>怎么样，是不是再也不用担心引号的问题了呢？不管你的query逻辑有多复杂，只要使用模板字符串就可以完全避免引号带来的问题，是不是很方便。</p>
<h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h2><p>今天简单的介绍了几个es6为我们带来的新功能，const和let，用来代替var，使变量声明更有逻辑性；以及模板字符串，使我们再也不用去拼接字符串了，<br>就像第一篇笔记说的，es6带来的新功能基本都是大家平时工作中最需要的功能，所以没有必要害怕es6，它只会让我们写js的时候更加方便，逻辑更加清晰。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[es6学习笔记之一 数组篇]]></title>
      <url>http://yoursite.com/cir0xtdcg00028gwzxl6sxw7k/</url>
      <content type="html"><![CDATA[<p>es6也称为es2015，是EcmaScript的第六个大版本，虽然已经推出很久了，但是我还是发现有很多码农仍然不使用es6的一些新特性。<br>我觉的其实没必要对这些新功能感到恐惧，要知道任何新功能的加入都是为了使这门编程语言更加完善。而且，能进入es6的新功能大多<br>是一些在业务中需求量很大的功能，而且很多库也都有着自己的实现。这个系列就是要向大家介绍一下es6为我们带来的一些新功能，而<br>且我觉的掌握这些功能基本能搞定平时80%的业务需求。</p>
<a id="more"></a>
<p>众所周知，array即数组是任何一门编程语言必不可少的数据类型或数据集合，JS也不例外，每个版本中都会为array增加许多新属性和<br>新方法。这篇文章会简单介绍一下es6为我们带来的7种新的array方法，如果你用过类似于underscore或者lodash这一类功能库，那<br>么其中的很多方法你一定不会感到陌生。</p>
<h2 id="1-ForEach"><a href="#1-ForEach" class="headerlink" title="1. ForEach"></a>1. ForEach</h2><p>我敢保证你在操作数组的时候一定使用过for循环，而今天我们将要介绍的这7种方法设计的目的就是让你摒弃for循环。为什么要这样做<br>呢？我觉的答案有三点：1. 简化代码，增加代码的可读性。2. 增加代码执行效率。3.提高你的逼格（这很重要）。</p>
<p>ForEach这个方法和for循环非常相似，可以用来遍历数组，大概长这个样子<br><code>arr.map(callback)</code><br>callback中的第一个参数为遍历的每一个元素，index为该元素的索引</p>
<p>让我们看一个简单的例子吧：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">var numbers = [1, 2, 3, 4];</span><br><span class="line"></span><br><span class="line">numbers.forEach(function(number)&#123;</span><br><span class="line">	console.log(number)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>这里的输出是<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1,0 </span><br><span class="line">2,1</span><br><span class="line">3,2</span><br><span class="line">4,3</span><br></pre></td></tr></table></figure></p>
<h2 id="2-map"><a href="#2-map" class="headerlink" title="2. map"></a>2. map</h2><p>map方法一般接受一个函数作为参数，返回一个新数组。大概就是这样：</p>
<p><code>arr.map(callback)</code></p>
<p>item就是arr遍历到的每个元素，相当于for循环中的<code>arr[i]</code>，让我们来看一个简单的例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">var numbers = [1, 2, 3, 4];</span><br><span class="line"></span><br><span class="line">var doubledNumbers = numbers.map(function(number)&#123;</span><br><span class="line">	return number * 2;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">console.log(doubledNumbers)//返回 [2, 4, 6, 8]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这个例子很简单，就是我们有一个数组，现在我想把每个数组里的元素X2，然后赋值给一个新书组。但是还是有三个点请大家注意一下：1.<br>callback函数一定要有return，否则就会返回undefined。2. map方法会返回一个新书组，从而做到不改变原数组的值，<br>即immutable。3. callback不一定是匿名函数，所以我们还可以这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">var numbers = [1, 2, 3, 4];</span><br><span class="line"></span><br><span class="line">function doubleNumbers(number)&#123;</span><br><span class="line">    return number * 2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var doubledNumbers = numbers.map(doubleNumbers);</span><br><span class="line"></span><br><span class="line">console.log(doubledNumbers)//返回 [2, 4, 6, 8]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>我们可以看到，返回的结果是完全一样的。</p>
<h2 id="3-filter"><a href="#3-filter" class="headerlink" title="3. filter"></a>3. filter</h2><p>filter是用来过滤数组的，它会给出一个条件，然后遍历数组，当数组的某个元素符合这个条件，这个元素就会被保留，反之就会被过滤掉，<br>然后返回一个新的数组。</p>
<p>filter的用法大概是这样<br><code>arr.filter(callback)</code><br>这里，callback通常接收一个参数，即被遍历到的元素，我们来看一个例子吧：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var numbers = [1, 2, 3, 4];</span><br><span class="line"></span><br><span class="line">var evenNumbers = numbers.filter(function(number)&#123;</span><br><span class="line">	return number % 2 === 0;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">console.log(evenNumbers)</span><br></pre></td></tr></table></figure>
<p>这个例子就是从numbers里面找到所有偶数元素，然后赋值给新数组evenNumbers。这里有两点需要注意：1. return一定不要忘了，2.<br>filter不会改变原数组，而是会返回一个新数组。这段代码运行的结果是 [2, 4]。</p>
<h2 id="4-find"><a href="#4-find" class="headerlink" title="4. find"></a>4. find</h2><p>find方法会接受一个条件，然后遍历数组，返回第一个符合该条件的元素，大概这样：<br><code>arr.find(callback)</code><br>同样，我们来看个例子吧：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var numbers = [1, 2, 3, 4];</span><br><span class="line"></span><br><span class="line">var numberFour = numbers.find(function(number)&#123;</span><br><span class="line">	return number === 4;</span><br><span class="line">&#125;)</span><br><span class="line">console.log(numberFour);</span><br></pre></td></tr></table></figure>
<p>这段代码返回的结果是4。要注意的一个问题是，当你的数组里有多个符合该条件的元素时，find方法只会返回第一个，而且，find方法只会<br>返回一个元素，而不是一个数组。举个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var numbers = [1, 2, 3, 4];</span><br><span class="line"></span><br><span class="line">var numberFour = numbers.find(function(number)&#123;</span><br><span class="line">	return number &gt;= 3;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">console.log(numberFour);</span><br></pre></td></tr></table></figure>
<p>这段代码返回的不是[3,4]，而是3，因为3是第一个符合条件的元素。如果你想让它执行上面的逻辑的话，那么请使用filter。</p>
<h2 id="5-every-some"><a href="#5-every-some" class="headerlink" title="5. every/some"></a>5. every/some</h2><p>把这两个方法放在一起说是因为他们非常相似，他们都是接受一个条件，如果这个数组的每一个元素都符合这个条件，every就会返回true。<br>如果这个数组中有任何一个元素符合这个条件，那么some就会返回true。所以我们可以说，我们给出一个条件，如果every的返回值是true<br>的话那么some一定也是true。</p>
<p>我们来看个例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var numbers = [1, 2, 3, 4];</span><br><span class="line">var allGreaterThan0 = numbers.every(function(number)&#123;</span><br><span class="line">	return number&gt;0;</span><br><span class="line">&#125;);</span><br><span class="line">console.log(allGreaterThan0);</span><br></pre></td></tr></table></figure></p>
<p>这段代码的返回结果是true，因为所有的元素都大于0。但是如果我们把条件稍微改改，改成number&gt;1，那么就会返回false，因为第一个<br>元素是1，1&gt;1是false。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var numbers = [1, 2, 3, 4];</span><br><span class="line">var allGreaterThan3 = numbers.some(function(number)&#123;</span><br><span class="line">	return number&gt;3;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">console.log(allGreaterThan3);</span><br></pre></td></tr></table></figure>
<p>这段代码的返回结果是true，因为最后一个元素4大于3。</p>
<p>every和some这两个方法要注意一个点：那就是这个方法不会返回任何数组或者值，只会返回true或false，所以我们可以在判断的时候使用<br>这两种方法，比如<code>if(arr.some(callback))...</code>，我们可以在外面定义callback方法，也可以用箭头函数（=&gt;）来定义，之后的文章<br>会介绍箭头函数。</p>
<h2 id="6-reduce"><a href="#6-reduce" class="headerlink" title="6. reduce"></a>6. reduce</h2><p>reduce方法是这7个方法中最绕的一个，不过不用担心，我们会详细的说说这个复(dan)杂(teng)的方法，尽量让大家明白。<br>reduce的作用是接受一个初始值和一个方法，对一个数组进行遍历，最后生成一个新的值，数据类型是初始值的数据类型，这么说肯定很绕，我<br>们来看几个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var numbers = [1, 2, 3, 4];</span><br><span class="line"></span><br><span class="line">var total = numbers.reduce(function(previous, number)&#123;</span><br><span class="line">  previous += number;</span><br><span class="line">	return previous; </span><br><span class="line">&#125;, 0)</span><br><span class="line"></span><br><span class="line">console.log(total);</span><br></pre></td></tr></table></figure>
<p>这段代码是把元素里面所有的值累加，并且返回所有元素相加的和，也就是10。我们来分块说一下，首先，reduce方法接受两个参数，第一个参数<br>是一个方法，我们一会再回来说它，先说第二个参数，这个参数是返回值的初始值，比如，再刚才那个例子里，如果我们的初始值给10而不是0，那<br>么结果就是20。回头来我们说说第一个参数，这个参数是reduce的规则，同样接受两个参数，以上面的例子来说，previous就是每次返回的值，<br>换句话说，我们每次都是都会返回这个值，用来做下一步的计算，而且reduce函数最后返回的值其实也是这个previous。第二个参数number则是<br>数组每次迭代的元素。也就是1，2，3，4。</p>
<p>我们来看个图表，理解一下reduce是怎么工作的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">迭代第一个元素之前：</span><br><span class="line">previous: 0, number: 1</span><br><span class="line">迭代第一个元素后：</span><br><span class="line">previous: 0+1=1, number: 1</span><br><span class="line">迭代第二个元素后：</span><br><span class="line">previous: 1+2=3, number: 2</span><br><span class="line">迭代第三个元素后：</span><br><span class="line">previous: 3+3=6, number: 3</span><br><span class="line">迭代第四个元素后：</span><br><span class="line">previous: 6+4=10, number: 4</span><br></pre></td></tr></table></figure>
<p>现在清晰很多了吧，对，reduce的第一个参数，也就是那个回调函数会执行4次，为每一个元素执行一次，最后返回总的值。</p>
<p>现在，我们来看两个非常实用的例子，在各种面试题里面非常常见：</p>
<ol>
<li>数组去重，就是说，给你个数组，[1, 1, 2, 3, 4, 4]大概这样，让你来写个方法，去掉重复的元素，返回[1, 2, 3, 4]。我建议你可以先不要往后<br>看，自己试试，如果想不出来或者不知道怎么用到reduce方法，请继续往后看。</li>
</ol>
<p>分析：<br>这里，首先我们要用reduce方法，那么我们要首先确定初始值，这里我们需要一个空数组，然后通过reduce的第一个参数那个callback每次往数组里<br>push。这步做完，我们应该有了这么一个轮廓：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var numbers = [1, 1, 2, 3, 4, 4];</span><br><span class="line"></span><br><span class="line">function unique(array) &#123;</span><br><span class="line">  return array.reduce((previous, number)=&gt;&#123;</span><br><span class="line">    </span><br><span class="line">  &#125;, []);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">unique(numbers);</span><br></pre></td></tr></table></figure></p>
<p>接下来，我们需要想想每次我们需要做什么，我们需要一个方法，接受每次传进来的数，然后看是不是包含在previous数组里，<br>确定某个元素是否包含在数组里有很多种方法，这里，我们可以用some方法，因为previous也是一个数组，但是，值得注意的<br>一点是这里我们需要的不是包含在数组里，而是不包含在previous数组里，所以我们需要取反。最后，如果取反得到的是true<br>的话，就说明这个数字不包含在previous数组里，所以，我们要把它push进previous。然后返回新的previous数组。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var numbers = [1, 1, 2, 3, 4, 4];</span><br><span class="line"></span><br><span class="line">function unique(array) &#123;</span><br><span class="line">  return array.reduce((previous, number)=&gt;&#123;</span><br><span class="line">    var eql = previous.some(function(num)&#123;</span><br><span class="line">    	return number === num;</span><br><span class="line">    &#125;);</span><br><span class="line">	  if(!eql)&#123;</span><br><span class="line">  	  previous.push(number)</span><br><span class="line">    &#125;</span><br><span class="line">    return previous;</span><br><span class="line">	&#125;, [])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">unique(numbers)</span><br></pre></td></tr></table></figure>
<p>这也就是最后的代码，当然，这段代码其实写的并不完美，有很多地方可以优化，但是这需要用到其他的es6的一些方法，比如…操作符<br>以及=&gt;箭头函数。在我们接触这些内容以前，先保持这样吧，如果对刚才我说的那两个概念有了解的同学可以自己尝试一下优化这段代码。<br>还有一点要注意的是，我写的这个并不是数组去重的最好解法，有兴趣的同学可以看一下es6中的Set。</p>
<ol>
<li>检查括号</li>
</ol>
<p>我们在刚开始学编程的时候，尤其是一开始用记事本写代码的时候，肯定会碰到这么个问题，括号的数量对不上，比如少半个左括号或者半<br>个右括号。现在，我们要写一个方法，用来检查一个字符串中的口号是否对称。举几个例子</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">function bracketMatch(str)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">var str1 = &apos;()&apos;;</span><br><span class="line">var str2 = &apos;(())&apos;;</span><br><span class="line">var str3 = &apos;()()&apos;;</span><br><span class="line">var str4 = &apos;((()))()&apos;;</span><br><span class="line">var str5 = &apos;((aaa))&apos;;</span><br><span class="line"></span><br><span class="line">var str6 = &apos;((())&apos;;</span><br><span class="line">var str7 = &apos;(((aaa))&apos;;</span><br><span class="line">var str8 = &apos;())&apos;;</span><br><span class="line">var str9 = &apos;)(&apos;;</span><br><span class="line">var str10 = &apos;)()(&apos;;</span><br><span class="line"></span><br><span class="line">bracketMatch(str1) //true</span><br><span class="line">bracketMatch(str2) //true</span><br><span class="line">bracketMatch(str3) //true</span><br><span class="line">bracketMatch(str4) //true</span><br><span class="line">bracketMatch(str5) //true</span><br><span class="line"></span><br><span class="line">bracketMatch(str6) //false</span><br><span class="line">bracketMatch(str7) //false</span><br><span class="line">bracketMatch(str8) //false</span><br><span class="line">bracketMatch(str9) //false</span><br><span class="line">bracketMatch(str10) //false</span><br></pre></td></tr></table></figure>
<p>还是和刚才那个例子一样，请大家先自己想一下，试着动手做做看，然后再往下继续看。</p>
<p>分析：</p>
<p>我们首先要做的一件事是把传入function的str转换成数组，这样才能调用数组的方法，所以我们第一步需要这么做<br><code>var strArr = str.split(&#39;&#39;)</code>。这样依赖我们会得到一个数组，每个元素就是str的每个字符。下一步我们想<br>一下，怎么才算平衡，假如我们把左括号（算作+1，右括号）算作-1的话，一个平衡的字符串我们需要让的每个元素<br>相加最后得到0，反之则说明不平衡。好，那么根据这个逻辑，我们想到应该使用reduce方法，把整个数组进行运算最<br>后得到一个整数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function bracketMatch(str)&#123;</span><br><span class="line">	var strArr = str.split(&apos;&apos;);</span><br><span class="line">    var result = strArr.reduce(function(previous, char)&#123;</span><br><span class="line">       if(char===&apos;(&apos;) return ++previous;</span><br><span class="line">       if(char===&apos;)&apos;) return --previous;</span><br><span class="line">  &#125;, 0);</span><br><span class="line">  return !result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里我们在reduce方法里先给一个0作为初始值，然后每一次迭代改变这个值，如果是左括号就+1，如果是右括号就减<br>1，这样一来我们得到的结果如果是0的话，就说明括号是对称的，就应该返回true，相反的，我们应该返回false。所以<br>我们在最后要给result取反，因为0是false，一切非0的数字都是true。</p>
<p>这里我们可以看到，80%的需求已经搞定了，现在我们还有两个问题：1.如果括号中参杂着其他字符，我们没办法处理。2.<br>如果先写右括号，然后在写左括号，也就是这样)(，我们的返回值仍然是true，因为reduce得到的数组也是0。下面我们<br>就要根据这两种情况对代码进行改进。</p>
<p>先说第一个问题，如果我们看到不是括号的内容，我们其实什么都不用做，只要让previous直接返回即可。也就是这样在<br>两个if之后加这么一条<code>return previous;</code>问题就解决了。然后我们反过来说第二个问题。我们来想一下，)(情况在我<br>们的逻辑里会出现什么事，对，没错，在走第一个右括号时，previous这个值会小于0。所以我们就从这一特性下手，我们<br>可以认为，一旦previous的值小于0，就说明)(情况已经发生了，所以后面其实也没有必要再运算下去了，不是么？所以我<br>们可以在所有的if条件前加一句<code>if(previous&lt;0) return previous;</code>，这样一来，只要有一次previous的值等于<br>-1的话，那么之后previous的值会一直满足&lt;0这个条件，也就是说previous的值一直会是-1。</p>
<p>整个代码是这样的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function bracketMatch(str)&#123;</span><br><span class="line">	var strArr = str.split(&apos;&apos;);</span><br><span class="line">  console.log(strArr);</span><br><span class="line">  var result = strArr.reduce(function(previous, char)&#123;</span><br><span class="line">    if(previous&lt;0) return previous;</span><br><span class="line">  	if(char===&apos;(&apos;) return ++previous;</span><br><span class="line">    if(char===&apos;)&apos;) return --previous;</span><br><span class="line">    return previous;</span><br><span class="line">  &#125;, 0);</span><br><span class="line">  return !result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="7-总结"><a href="#7-总结" class="headerlink" title="7.总结"></a>7.总结</h2><p>这里为大家介绍了7种es6中数组新增的方法，这些方法有很多通性，而且这里也为大家介绍了两个比较好的理念，第一就是尽量不<br>要直接修改数组的值，而是用一些方法返回新的值。还有一个就是尽量不要在代码中只用for循环进行迭代，其实大家应该已经发现<br>了，这些功能其实都是我们平时很需要的功能，而且根本没有什么高深的。其实我们这个系列的宗旨就是给大家介绍一些es6中最实<br>用而且最常见的新功能。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[reselect与redux]]></title>
      <url>http://yoursite.com/cir0xtdco00068gwzvk875rz6/</url>
      <content type="html"><![CDATA[<h2 id="1-reselect简介"><a href="#1-reselect简介" class="headerlink" title="1. reselect简介"></a>1. reselect简介</h2><p>reselect是一个与redux配合使用的一个模块，它可根据state上的多个已有的属性来生成一个新的属性，<br>这可以为简化代码逻辑带来很大的帮助。比如我们在state上有users这个属性，而在每个user上又有性别<br>这个属性，那么我们可以使用reselect来为我们分别生成性别为男和女的新属性，而且也不需要加入新的<br>reducer和action。</p>
<a id="more"></a>
<h2 id="2-一个简单的例子"><a href="#2-一个简单的例子" class="headerlink" title="2. 一个简单的例子"></a>2. 一个简单的例子</h2><h3 id="现在我们有一个简单的文章系统，大概是这样的："><a href="#现在我们有一个简单的文章系统，大概是这样的：" class="headerlink" title="现在我们有一个简单的文章系统，大概是这样的："></a>现在我们有一个简单的文章系统，大概是这样的：</h3><img src="/cir0xtdco00068gwzvk875rz6/articles_1.png" alt="articles_1.png" title="">
<h3 id="文件目录大概这样："><a href="#文件目录大概这样：" class="headerlink" title="文件目录大概这样："></a>文件目录大概这样：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">|- actions/</span><br><span class="line">|--- types.js  //存放所有action.type</span><br><span class="line">|--- index.js   //action creators</span><br><span class="line">|- components/</span><br><span class="line">|--- app.js    //入口组件</span><br><span class="line">|--- containers/</span><br><span class="line">|------ post_list.js //显示已被选中的文章</span><br><span class="line">|------ post_selectors.js    //所有文章，点击checkbox会加入被选中的文章列表</span><br><span class="line">|- reducers/</span><br><span class="line">|--- all_post_reducer.js  //返回所有文章</span><br><span class="line">|--- index.js     //combinedReducer</span><br><span class="line">|--- select_post_reducer.js   //返回被选中或者被反选的文章</span><br><span class="line">|-index.js  //主入口</span><br></pre></td></tr></table></figure>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><p><strong> /index.js </strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">import React from &apos;react&apos;;</span><br><span class="line">import ReactDOM from &apos;react-dom&apos;;</span><br><span class="line">import &#123; Provider &#125; from &apos;react-redux&apos;;</span><br><span class="line">import &#123; createStore, applyMiddleware &#125; from &apos;redux&apos;;</span><br><span class="line">import reduxThunk from &apos;redux-thunk&apos;;</span><br><span class="line"></span><br><span class="line">import App from &apos;./components/app&apos;;</span><br><span class="line">import reducers from &apos;./reducers&apos;;</span><br><span class="line"></span><br><span class="line">const createStoreWithMiddleware = applyMiddleware(</span><br><span class="line">    reduxThunk</span><br><span class="line">)(createStore);</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;Provider store=&#123;createStoreWithMiddleware(reducers)&#125;&gt;</span><br><span class="line">    &lt;App /&gt;</span><br><span class="line">  &lt;/Provider&gt;</span><br><span class="line">  , document.querySelector(&apos;.container&apos;));</span><br></pre></td></tr></table></figure></p>
<p><strong> /components/app.js </strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123; Component &#125; from &apos;react&apos;;</span><br><span class="line"></span><br><span class="line">import PostSelector from &apos;./containers/post_selectors&apos;;</span><br><span class="line">import PostList from &apos;./containers/post_list&apos;</span><br><span class="line"></span><br><span class="line">export default class App extends Component &#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;PostList /&gt;</span><br><span class="line">        &lt;PostSelector /&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong> /components/containers/post_selectors.js </strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123; Component &#125; from &apos;react&apos;;</span><br><span class="line">import &#123; connect &#125; from &apos;react-redux&apos;;</span><br><span class="line">import &#123; bindActionCreators &#125; from &apos;redux&apos;</span><br><span class="line"></span><br><span class="line">import &#123; getPosts, selectPost, deselectPost &#125; from &apos;../../actions/index&apos;;</span><br><span class="line"></span><br><span class="line">class PostSelector extends Component &#123;</span><br><span class="line">    componentWillMount()&#123;</span><br><span class="line">        this.props.getPosts();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    handleCheck(postId, event)&#123;</span><br><span class="line">        if(event.target.checked)&#123;</span><br><span class="line">            this.props.selectPost(postId)</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            this.props.deselectPost(postId)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    renderPostList()&#123;</span><br><span class="line">        return this.props.posts.map(post =&gt; &#123;</span><br><span class="line">            return (</span><br><span class="line">                &lt;li className=&quot;list-group-item&quot; key=&#123;post.id&#125;&gt;</span><br><span class="line">                    &lt;input</span><br><span class="line">                        type=&quot;checkbox&quot;</span><br><span class="line">                        value=&#123;this.props.selectedIds.includes(post.id)&#125;</span><br><span class="line">                        onChange=&#123;this.handleCheck.bind(this, post.id)&#125;</span><br><span class="line">                    /&gt;</span><br><span class="line">                    &#123;post.title&#125;</span><br><span class="line">                &lt;/li&gt;</span><br><span class="line">            )</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    render()&#123;</span><br><span class="line">        //console.log(this.props.posts)</span><br><span class="line">       if(this.props.posts)&#123;</span><br><span class="line">           return (</span><br><span class="line">               &lt;div&gt;</span><br><span class="line">                   &lt;h2&gt;文章列表&lt;/h2&gt;</span><br><span class="line">                   &lt;ul className=&quot;list-group&quot;&gt;</span><br><span class="line">                       &#123;this.renderPostList()&#125;</span><br><span class="line">                   &lt;/ul&gt;</span><br><span class="line">               &lt;/div&gt;</span><br><span class="line">           )</span><br><span class="line">       &#125;else&#123;</span><br><span class="line">           return &lt;h2&gt;Loading...&lt;/h2&gt;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function mapStateToProps(state)&#123;</span><br><span class="line">    return &#123;</span><br><span class="line">        posts: state.posts,</span><br><span class="line">        selectedIds: state.selectedIds</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function mapDispatchToProps(dispatch)&#123;</span><br><span class="line">    return bindActionCreators(&#123;</span><br><span class="line">        getPosts,</span><br><span class="line">        selectPost,</span><br><span class="line">        deselectPost</span><br><span class="line">    &#125;, dispatch)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default connect(mapStateToProps, mapDispatchToProps)(PostSelector);</span><br></pre></td></tr></table></figure></p>
<p><strong> /components/containers/post_list.js </strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123; Component &#125; from &apos;react&apos;;</span><br><span class="line"></span><br><span class="line">export default class PostList extends Component &#123;</span><br><span class="line">    render()&#123;</span><br><span class="line">        return (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;h2&gt;已选中的文章&lt;/h2&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong> /actions/types.js </strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">export const GETPOSTS = &apos;GETPOSTS&apos;;</span><br><span class="line">export const SELECTPOST = &apos;SELECTPOST&apos;;</span><br><span class="line">export const DESELECTPOST = &apos;DESELECTPOST&apos;;</span><br></pre></td></tr></table></figure></p>
<p><strong> /actions/index.js </strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">import axios from &apos;axios&apos;;</span><br><span class="line">import _ from &apos;lodash&apos;;</span><br><span class="line"></span><br><span class="line">import &#123; GETPOSTS, SELECTPOST, DESELECTPOST &#125; from &apos;./types&apos;;</span><br><span class="line"></span><br><span class="line">export function getPosts()&#123;</span><br><span class="line">    return dispatch =&gt; &#123;</span><br><span class="line">        const fetchUrl = &apos;http://jsonplaceholder.typicode.com/posts&apos;;</span><br><span class="line">        axios.get(fetchUrl).then(response=&gt;&#123;</span><br><span class="line">            if(response.status == 200)&#123;</span><br><span class="line">                dispatch(&#123;</span><br><span class="line">                    type: GETPOSTS,</span><br><span class="line">                    payload: response.data.slice(0, 5)</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export function selectPost(postId)&#123;</span><br><span class="line">    return dispatch =&gt; &#123;</span><br><span class="line">        dispatch(&#123;</span><br><span class="line">            type: SELECTPOST,</span><br><span class="line">            payload: postId</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export function deselectPost(postId)&#123;</span><br><span class="line">    return &#123;</span><br><span class="line">        type: DESELECTPOST,</span><br><span class="line">        payload: postId</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong> /reducers/index.js </strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import &#123; combineReducers &#125; from &apos;redux&apos;;</span><br><span class="line">import all_post_reducer from &apos;./all_post_reducer&apos;;</span><br><span class="line">import select_post_reducer from &apos;./select_post_reducer&apos;;</span><br><span class="line"></span><br><span class="line">const rootReducer = combineReducers(&#123;</span><br><span class="line">  posts: all_post_reducer,</span><br><span class="line">  selectedIds: select_post_reducer</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">export default rootReducer;</span><br></pre></td></tr></table></figure></p>
<p><strong> /reducers/all_post_reducer.js </strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">import &#123; GETPOSTS, SELECTPOST, DESELECTPOST &#125; from &apos;../actions/types&apos;;</span><br><span class="line"></span><br><span class="line">export default function(state=[], action)&#123;</span><br><span class="line">    switch(action.type)&#123;</span><br><span class="line">        case GETPOSTS:</span><br><span class="line">            return action.payload;</span><br><span class="line"></span><br><span class="line">        default:</span><br><span class="line">            return state;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong> /reducers/select_post_reducer.js </strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">import &#123; GETPOSTS, SELECTPOST, DESELECTPOST &#125; from &apos;../actions/types&apos;;</span><br><span class="line"></span><br><span class="line">export default function(state=[], action)&#123;</span><br><span class="line">    switch(action.type)&#123;</span><br><span class="line">        case SELECTPOST:</span><br><span class="line">            return [...state, action.payload];</span><br><span class="line"></span><br><span class="line">        case DESELECTPOST:</span><br><span class="line">            return state.filter(id=&gt; id!=action.payload);</span><br><span class="line"></span><br><span class="line">        default:</span><br><span class="line">            return state;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="代码概述："><a href="#代码概述：" class="headerlink" title="代码概述："></a>代码概述：</h3><p>这是一个很简单的react-redux项目，通过两个action creator来向reducer发送action，并且<br>生成新的state，这里state中共有两个属性，1，包含所有文章的数组，这里可以看出来，我们使用的是jsonplaceholder<br>中的post并且只取了前5个。2，包含所有已经被选的文章Id数组，这个数组只包含文章的Id，大概是这样的<br><code>[1, 2, 4]</code>。用户可以通过选择或反选文章左侧的checkbox来进行选择或者反选文章，其实就是往被选文章数组内<br>添加当前文章Id或者是从被选文章数组内移除当前文章的Id。</p>
<h3 id="一点题外话"><a href="#一点题外话" class="headerlink" title="一点题外话"></a>一点题外话</h3><p>我在写这个小例子的时候除了个小状况，而且，我觉得应该很多人都出过这种状况吧。当时我差不多写好的时候，<br>发现不管是选择还是反选文章前的checkbox，被选文章的数组始终是个空数组，经过一番排查，发现错误很诡异<br>action creator方法确实执行了，但是reducer却没有反应，而且浏览器没有报任何错误，换句话说，reducer<br>没有接收到action creator发出的action。经过长(da)时(shen)间(de)调(zhi)试(dian)，最终发现bug的所在：<br><strong> 我在组件中调用actioncreator 方法的时候忘了加 this.props </strong> 这么做会导致在action creator被<br>调用的时候，它调用的不是props上的那个redux包装过的action creator，而是调用的import进来的那个包装前的。<br>要知道，在bindActionCreator执行的时候，里面的方法已经跟redux绑定在了一起，但是之前那个import进来的<br>只是一个纯函数，可以执行，然后return一个action object，并不会dispatch给reducer。这个错误我觉的应该<br>不是我一个人犯过，所以大家看了以后，如果你的action creator可以正常以运行但是reducer却接不到任何一个<br>action，而且浏览器不报任何错误，那么多半就是这个原因了，检查一下你在运行action creator的时候是不是<br>忘了加this.props吧。</p>
<h2 id="3-补全post-list"><a href="#3-补全post-list" class="headerlink" title="3. 补全post_list"></a>3. 补全post_list</h2><p>可以看出来，post_list根本就没写完，目前，它只能显示一个h2标签。我们需要它在有文章被勾选时显示这个文章，<br>再文章被反选时把这个文章移除。那么很明显，它需要是一个Smart Component，就是说它需要和state tree相关联。</p>
<h3 id="state-tree已绑定的属性"><a href="#state-tree已绑定的属性" class="headerlink" title="state tree已绑定的属性"></a>state tree已绑定的属性</h3><p>目前我们的state tree上已经绑定了这些：</p>
<ol>
<li>所有的文章</li>
<li>一个包含已选中文章Id的数组</li>
</ol>
<p>那么目前看来，单纯用redux来解决的话大概有两个解决方案：</p>
<ol>
<li><p>在state tree上新增加一个数组，里面包含所有被选中的文章（不是只有文章Id），然后把这个属性绑在post_list上。<br>这样一来我们需要重写post_selectors.js这个组件，在选中或者反选时调用一个新的action creator，而这个action<br>creator的作用就是根据参数传入的Id来对所有文章的数组进行过滤，把Id为参数传入的那个文章作为payload传给reducer，<br>最后reducer把那个文章加入到新书组内并且返回新的数组。</p>
</li>
<li><p>在post_list的componentWillMount时对所有文章的数组进行过滤，只保留Id包含在被选文章Id数组内的文章，然后对<br>其进行渲染。</p>
</li>
</ol>
<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>这两种解决办法都有一定的问题，第一种做法使得逻辑变得复杂，因为要在state上加入新的属性，并且需要加入新的<br>action creator以及reducer。第二种方法虽然看似简单，但是却使得组件的复用性变差了，如果我之后想做一个新的post_list<br>里面只显示没有选中的文章，那么就没办法服用这个组件，因为componentWillMount方法的逻辑不同。</p>
<h2 id="4-解决方案"><a href="#4-解决方案" class="headerlink" title="4. 解决方案"></a>4. 解决方案</h2><p>在redux生态系统中，有这么个东西，叫做reselect，<a href="https://github.com/reactjs/reselect" target="_blank" rel="external">GitHub 连接</a>，这个<br>模块能很好的解决我们目前的问题。首先，我们知道post_list上需要的文章并不是新的文章，而是由所有文章和已选中文章Id的<br>数组进行过滤后得到的。如果state tree上的某个属性是由其他属性进行某种逻辑运算后得到的，那么我们就可以考虑使用reselect。</p>
<h3 id="使用reselect"><a href="#使用reselect" class="headerlink" title="使用reselect"></a>使用reselect</h3><p>首先为了让文件目录更清晰，我们在根目录下新增加一个文件夹，叫selectors用来存放所有的selector，至于selector是什么，<br>我们马上就知道了，目前的文件目录大概是这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">|- actions/</span><br><span class="line">|--- types.js  //存放所有action.type</span><br><span class="line">|--- index.js   //action creators</span><br><span class="line">|- components/</span><br><span class="line">|- selectors/   //包含所有selector</span><br><span class="line">|--- select_post_selector.js    //负责生成被选中的文章</span><br><span class="line">|--- app.js    //入口组件</span><br><span class="line">|--- containers/</span><br><span class="line">|------ post_list.js //显示已被选中的文章</span><br><span class="line">|------ post_selectors.js    //所有文章，点击checkbox会加入被选中的文章列表</span><br><span class="line">|- reducers/</span><br><span class="line">|--- all_post_reducer.js  //返回所有文章</span><br><span class="line">|--- index.js     //combinedReducer</span><br><span class="line">|--- select_post_reducer.js   //返回被选中或者被反选的文章</span><br><span class="line">|-index.js  //主入口</span><br></pre></td></tr></table></figure>
<p><strong> /selectors/select_post_selector.js </strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import &#123; createSelector &#125; from &apos;reselect&apos;;</span><br><span class="line"></span><br><span class="line">const allPostSelector = state =&gt; state.posts;</span><br><span class="line">const selectedIdSelector = state =&gt; state.selectedIds;</span><br><span class="line"></span><br><span class="line">const getSelectedPosts = (posts, selectedIds) =&gt; &#123;</span><br><span class="line">    return posts.filter(post =&gt; selectedIds.includes(post.id));</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">export default createSelector(allPostSelector, selectedIdSelector, getSelectedPosts);</span><br></pre></td></tr></table></figure></p>
<p>大概说一下，allPostSelector一个函数，它会在state tree上找到posts这个属性，也就是所有文章的数组，<br>selectedIdSelector和allPostSelector类似，会在state tree上找到selectedIds属性，也就是那个<br>包含所有被选文章Id的数组。</p>
<p>getSelectedPosts也是一个函数，它接收多个参数，然后返回根据这些参数生成的新属性，这个属性最后会绑定<br>到state tree上。</p>
<p>然后我们需要在post_list这一组件中使用这个用reselect生成的新属性<br><strong> /components/containers/post_list.js </strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123; Component &#125; from &apos;react&apos;;</span><br><span class="line">import &#123; connect &#125; from &apos;react-redux&apos;;</span><br><span class="line"></span><br><span class="line">import PostSelector from &apos;../../selectors/select_post_selector&apos;;</span><br><span class="line"></span><br><span class="line">class PostList extends Component &#123;</span><br><span class="line"></span><br><span class="line">    renderPostLists()&#123;</span><br><span class="line">        return this.props.selectedPosts.map(post=&gt;&#123;</span><br><span class="line">            return (</span><br><span class="line">                &lt;li className=&quot;list-group-item&quot; key=&#123;post.id&#125;&gt;&#123;post.title&#125;&lt;/li&gt;</span><br><span class="line">            )</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    render()&#123;</span><br><span class="line">        return (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;h2&gt;已选中的文章&lt;/h2&gt;</span><br><span class="line">                &lt;ul className=&quot;list-group&quot;&gt;</span><br><span class="line">                    &#123;this.renderPostLists()&#125;</span><br><span class="line">                &lt;/ul&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function mapStateToProps(state)&#123;</span><br><span class="line">    return &#123;</span><br><span class="line">        selectedPosts: PostSelector(state)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default connect(mapStateToProps)(PostList);</span><br></pre></td></tr></table></figure></p>
<p>这个组件其实基本和使用redux对state进行绑定后的Smart组件没什么区别，唯一一点值得<br>注意的是第30行，<code>selectedPosts: PostSelector(state)</code>这里。我们只是用刚才写好<br>的selector对state进行加工，用已有的属性（所有post和被选postId）来生成这个新的属性。</p>
<h2 id="5-小结"><a href="#5-小结" class="headerlink" title="5. 小结"></a>5. 小结</h2><p>运行一下，一切都没问题，而且这样一来，post_list这个组件也可以很好的复用了。值得注意的<br>是，现在这个小例子只是为了向大家简单介绍一下reselect这个模块，或许你感觉不到使用reselect<br>的必要性，但是，要知道这个例子中的state tree结构非常简单，但是当在实际开发中，业务逻辑往往<br>会变得十分复杂，这也就导致了state tree结构也会变得复杂，通过这种方式来简化state tree将会<br>是一种非常好的优化手段。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[浅谈React Router中的browserHistory和hashHistory]]></title>
      <url>http://yoursite.com/cir0xtdcr00088gwz0hlut6xz/</url>
      <content type="html"><![CDATA[<h2 id="React-Router简述"><a href="#React-Router简述" class="headerlink" title="React Router简述"></a>React Router简述</h2><p>React router，即路由，是react生态系统中一个重要的组成部分。它可以使单页应用具有类似于多页应用的<br>路由系统，即前端路由。绝对多数教程中对于Router History中的browserHisotry和hashHistory都是<br>一笔带过：不要用hashHistory，用brwoserHistory，其实在开发中，并没有那么简单，hashhistory有着<br>一定的应用场景，而browserHistory也会有几个坑。</p>
<a id="more"></a>
<h2 id="1-hashHistory-vs-browserHistory"><a href="#1-hashHistory-vs-browserHistory" class="headerlink" title="1. hashHistory vs browserHistory"></a>1. hashHistory vs browserHistory</h2><p>现在，有这么一个简单的小例子：</p>
<p>index.js:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">import React from &apos;react&apos;;</span><br><span class="line">import ReactDOM from &apos;react-dom&apos;;</span><br><span class="line">import &#123; Provider &#125; from &apos;react-redux&apos;;</span><br><span class="line">import &#123; createStore, applyMiddleware &#125; from &apos;redux&apos;;</span><br><span class="line">import &#123; Router, Route, browserHistory, hashHistory&#125; from &apos;react-router&apos;;</span><br><span class="line"></span><br><span class="line">import App from &apos;./components/app&apos;;</span><br><span class="line">import reducers from &apos;./reducers&apos;;</span><br><span class="line">import User from &apos;./components/user&apos;;</span><br><span class="line"></span><br><span class="line">const createStoreWithMiddleware = applyMiddleware()(createStore);</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;Provider store=&#123;createStoreWithMiddleware(reducers)&#125;&gt;</span><br><span class="line">    &lt;Router history=&#123;hashHistory&#125;&gt;</span><br><span class="line">        &lt;Route path=&quot;/&quot; component=&#123;App&#125; &gt;</span><br><span class="line">            &lt;Route path=&quot;user&quot; component=&#123;User&#125; /&gt;</span><br><span class="line">        &lt;/Route&gt;</span><br><span class="line">    &lt;/Router&gt;</span><br><span class="line">  &lt;/Provider&gt;</span><br><span class="line">  , document.querySelector(&apos;.container&apos;));</span><br><span class="line">  </span><br></pre></td></tr></table></figure></p>
<p>app.js:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123; Component &#125; from &apos;react&apos;;</span><br><span class="line">import &#123; Link &#125; from &apos;react-router&apos;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">export default class App extends Component &#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;Link to=&quot;user&quot;&gt;&lt;h2&gt;User&lt;/h2&gt;&lt;/Link&gt;</span><br><span class="line">        &#123;this.props.children&#125;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p>user.js:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123; Component &#125; from &apos;react&apos;;</span><br><span class="line"></span><br><span class="line">export default class User extends Component &#123;</span><br><span class="line">    render()&#123;</span><br><span class="line">        return (</span><br><span class="line">            &lt;h3&gt;User Component&lt;/h3&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="在webpack-dev-server下的运行效果大概是这样："><a href="#在webpack-dev-server下的运行效果大概是这样：" class="headerlink" title="在webpack-dev server下的运行效果大概是这样："></a>在webpack-dev server下的运行效果大概是这样：</h3><p>/<br><img src="/cir0xtdcr00088gwz0hlut6xz/home_hash.png" alt="home_hash.png" title=""></p>
<p>/user<br><img src="/cir0xtdcr00088gwz0hlut6xz/user_hash.png" alt="user_hash.png" title=""></p>
<p>注意到地址栏里那一串奇怪的字符串了么（?_k=jgh8bl），这是hashHistory为我们自动添加的，<br>而且，当我们访问/user时，路径也很奇怪。</p>
<h3 id="接下来我们来试着把history-hashHistory-换成history-browserHistory-试试，"><a href="#接下来我们来试着把history-hashHistory-换成history-browserHistory-试试，" class="headerlink" title="接下来我们来试着把history = {hashHistory}换成history = {browserHistory}试试，"></a>接下来我们来试着把<code>history = {hashHistory}</code>换成<code>history = {browserHistory}</code>试试，</h3><p>/<br><img src="/cir0xtdcr00088gwz0hlut6xz/home_browser.png" alt="home_browser.png" title=""></p>
<p>/user<br><img src="/cir0xtdcr00088gwz0hlut6xz/user_browser.png" alt="user_browser.png" title=""></p>
<p><em>注意，这里有个小坑，在webpack.config.js中，我们需要在devServer里面加一个</em><br><em><code>historyApiFallback: true</code>的配置项，这一点大家应该都知道，所以就不赘述了。</em></p>
<p>嗯，这次地址栏清爽多了，没有奇怪的字符串，一切都正常了。似乎browserHistory这种<br>方式明显比hashHistory好很多。但是，这里要说一下，如果我们有意不希望用户直接通过<br>地址栏访问user路由的话，就可以使用hashHistory。</p>
<h2 id="2-生产环境"><a href="#2-生产环境" class="headerlink" title="2.生产环境"></a>2.生产环境</h2><p>假如现在项目写完了，需要部署到生产环境下，那么webpack-devserver就不能用了。现在<br>我们需要做两件事：1.写个简单的node服务器，2.用webpack对项目进行打包，生成bundle.js</p>
<h3 id="1-node服务器"><a href="#1-node服务器" class="headerlink" title="1. node服务器"></a>1. node服务器</h3><p>因为整个项目只需要index.html和bundle.js这两个文件，所以我们可以写个简单的静态<br>服务器，这里，我们用express来写，几行代码就能搞定。</p>
<p>server.js:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const express = require(&apos;express&apos;);</span><br><span class="line">const path = require(&apos;path&apos;);</span><br><span class="line"></span><br><span class="line">const app = express();</span><br><span class="line"></span><br><span class="line">app.use(express.static(__dirname));</span><br><span class="line"></span><br><span class="line">app.listen(8080);</span><br></pre></td></tr></table></figure>
<p>当浏览器访问/的时候，服务器就会默认发送index.js给浏览器，由于这个机制的存在，我们不用<br>配置任何路由，注意，这里的路由说的不是前端路由。</p>
<h3 id="2-webpack打包"><a href="#2-webpack打包" class="headerlink" title="2. webpack打包"></a>2. webpack打包</h3><p>webpack.config.js:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">  entry: [</span><br><span class="line">    &apos;./src/index.js&apos;</span><br><span class="line">  ],</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: __dirname,</span><br><span class="line">    publicPath: &apos;/&apos;,</span><br><span class="line">    filename: &apos;bundle.js&apos;</span><br><span class="line">  &#125;,</span><br><span class="line">  module: &#123;</span><br><span class="line">    loaders: [&#123;</span><br><span class="line">      exclude: /node_modules/,</span><br><span class="line">      loader: &apos;babel&apos;,</span><br><span class="line">      query: &#123;</span><br><span class="line">        presets: [&apos;react&apos;, &apos;es2015&apos;, &apos;stage-1&apos;]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;]</span><br><span class="line">  &#125;,</span><br><span class="line">  resolve: &#123;</span><br><span class="line">    extensions: [&apos;&apos;, &apos;.js&apos;, &apos;.jsx&apos;]</span><br><span class="line">  &#125;,</span><br><span class="line">  devServer: &#123;</span><br><span class="line">    historyApiFallback: true,</span><br><span class="line">    contentBase: &apos;./&apos;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在跟路径下打开命令行里输入<code>webpack -p</code>就会生成一个打包好的文件，我们给它起名为bundle.js。<br>现在把webpack-devserver停掉，然后运行server.js，<code>node server.js</code>，之后访问server<br>指定的端口（8080）应该就会看到正常的页面了。</p>
<p>/<br><img src="/cir0xtdcr00088gwz0hlut6xz/home_browser.png" alt="home_browser.png" title=""></p>
<p>/user<br><img src="/cir0xtdcr00088gwz0hlut6xz/user_browser.png" alt="user_browser.png" title=""></p>
<p>貌似一切都OK了，但是，当我们在/user下刷新一下时就不太OK了。。。<br>/user<br><img src="/cir0xtdcr00088gwz0hlut6xz/user_error.png" alt="user_error.png" title=""></p>
<p>页面中显示的”Cannot GET user”是express给我们响应回来的内容，并不是我们刚才写的user.js，<br>也就是说，浏览器并没有使用我们react-router中给出的路由。</p>
<p>其实原因很简单，因为react-router中的路由实际上是前端路由，并不是真正意义上的路由。说白了，<br>不管你请求什么地址，前端路由都不会让浏览器向服务器发送请求，而是在前端直接做处理，然后给用户<br>看相应的页面，也就是说，无论用户请求什么路径，其实用户一直都是在index页面上。</p>
<p>这一点我们同样可以在浏览器的console里的Network中得到证实，理论上，当我们点击user链接或者在<br>浏览器中手动切换到/user时，浏览器并没有向服务器请求新的页面。但是，当我们真的部署到生产环境时，<br>在浏览器手动切换/user或者刷新时，浏览器并不知道我们其实是想让前端路由来做处理并且不发送请求给<br>服务器的，所以依然会发请求给服务器，请求/user，然后服务器没有相关的配置，所以就返回一个默认的<br>404页面给浏览器。</p>
<p>如果我们这里使用的是hashHistory，就不会有这个问题，因为hashHistory在路径后面加了一个#符号，<br>这就相当于告诉浏览器不要向服务器发请求。</p>
<h3 id="3-改进server-js"><a href="#3-改进server-js" class="headerlink" title="3. 改进server.js"></a>3. 改进server.js</h3><p>这里我们如果仍然想使用browserHistory的话，就要对服务器端进行改进，其实做法很简单，就是添加一个<br>匹配所有路径的配置，然后让这个配置返回index.html，也就是说无论浏览器请求什么路径，都会返回index.html<br>然后浏览器的前端路由（react-router）就能开始工作了。</p>
<p>server.js:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">const express = require(&apos;express&apos;);</span><br><span class="line">const path = require(&apos;path&apos;);</span><br><span class="line"></span><br><span class="line">const app = express();</span><br><span class="line"></span><br><span class="line">app.use(express.static(__dirname));</span><br><span class="line"></span><br><span class="line">app.get(&apos;*&apos;, (req, res)=&gt;&#123;</span><br><span class="line">    res.sendFile(path.resolve(__dirname, &apos;index.html&apos;));</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.listen(8080);</span><br></pre></td></tr></table></figure>
<p>然后重启服务器，一切就正常了，而且没有向在切换到/user时向服务器发送新的请求，这说明前端路由也能正常<br>工作了。而且，当我们访问一个不存在的路径时，比如(/abcde)，服务器也没有显示默认的<code>Cannot GET</code>页面<br>而是在控制台里报了个warning，说不能找到相应的路径。</p>
<h3 id="4-关于其他路径"><a href="#4-关于其他路径" class="headerlink" title="4. 关于其他路径"></a>4. 关于其他路径</h3><p>也许会有同学问，如果我的服务器还配置了一套API在/api路径下，那么这套API是不是就不能用了。答案是不会。<br>但是我们要把这些配置写在<code>app.get(&#39;*&#39;)</code>之前。因为express是按照配置的顺序来对请求进行匹配的，如果写<br>在<code>app.get(&#39;*&#39;)</code>之后，就会先匹配到/*，因为成功匹配上了，就会返回index.html。</p>
<p>server.js:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">const express = require(&apos;express&apos;);</span><br><span class="line">const path = require(&apos;path&apos;);</span><br><span class="line"></span><br><span class="line">const app = express();</span><br><span class="line"></span><br><span class="line">app.use(express.static(__dirname));</span><br><span class="line"></span><br><span class="line">app.get(&apos;/api&apos;, (req, res)=&gt;&#123;</span><br><span class="line">    res.json(&#123;username: &apos;abc&apos;&#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.get(&apos;*&apos;, (req, res)=&gt;&#123;</span><br><span class="line">    res.sendFile(path.resolve(__dirname, &apos;index.html&apos;));</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.listen(8080);</span><br></pre></td></tr></table></figure>
<p>这时我们访问/和/user时，一切正常，并且当我们访问/api时，也可以得到相应的内容。</p>
<p>/api<br><img src="/cir0xtdcr00088gwz0hlut6xz/api_img.png" alt="api_img.png" title=""></p>
<h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h2><p>我们简略的分析了一下browserHistory和hashHistory的一些区别，并且做了个简单的<br>生产环境部署，以及踩了browserHistory在生产环境下的一个小坑。总的来说，一般情况<br>下我们都会选用在地址栏显示清爽的browserHistory，但是在一些情况下，hashHistory<br>也有者它的好处。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Node中的事件系统]]></title>
      <url>http://yoursite.com/cir0xtdh9000w8gwzh63p50hz/</url>
      <content type="html"><![CDATA[<h2 id="Node中的事件发布与订阅"><a href="#Node中的事件发布与订阅" class="headerlink" title="Node中的事件发布与订阅"></a>Node中的事件发布与订阅</h2><p>事件的发布和订阅系统(event)是NodeJS中的一个极为重要的系统，但是这个系统对于很多刚入坑的小伙伴来说可能难以理解，<br>这篇博客会为刚入坑的小伙伴们简单介绍一下事件（event），并且一步一步的写一个“山寨版”的事件系统。</p>
<a id="more"></a>
<h3 id="1-什么是事件系统"><a href="#1-什么是事件系统" class="headerlink" title="1. 什么是事件系统"></a>1. 什么是事件系统</h3><p>事件系统其实就是NodeJS中的一个模块（Events），这个模块使得NodeJS具有对事件的监听和触发的动能。<br>比如说，我们可以制定一个机制，一旦一个文件读取完毕，我们会做什么事情，比如将文件内容打印出来或者进行修改。<br>事件系统是NodeJS中的一个极其重要的系统，因为Javascript语言原本是前端的脚本语言，对于这种事件机制支持<br>比较弱，而这种机制又是后端语言必备的，所以NodeJS实现了一套很完善的事件系统。许多初识Node的同学可能<br>会觉得事件机制比较难理解，但其实真没有那么难。</p>
<h3 id="2-如何使用事件系统"><a href="#2-如何使用事件系统" class="headerlink" title="2. 如何使用事件系统"></a>2. 如何使用事件系统</h3><p>在NodeJS中有个模块叫做Events，它的作用就是让我们很容易的去使用事件。</p>
<ol>
<li><p>首先，要导入events模块。由于这个模块是一个构造函数，所以我们需要new一个event实例。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var Events = require(&apos;events&apos;);</span><br><span class="line"></span><br><span class="line">var myEvent = new Events();</span><br></pre></td></tr></table></figure>
</li>
<li><p>在这个实例的原型上有很多方法，这里只说两个最简单的，其他的可以在<a href="https://nodejs.org/dist/latest-v6.x/docs/api/events.html" target="_blank" rel="external">NodeJS的官方API</a>上面看到。<br><em>on</em>方法负责定义事件并且绑定到一个监听者（listener）上，就像这样</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">myEvent.on(&apos;hello&apos;, function()&#123;</span><br><span class="line">    console.log(&apos;hello back&apos;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>这里，我们定义了一个名为hello的事件，而监听者一旦发现这个事件被触发了，就会执行function里面的内容。</p>
</li>
<li><p>一个事件上可以绑定多个监听者，所以我们再为这个名为hello的事件绑定一个吧</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">myEvent.on(&apos;hello&apos;, function()&#123;</span><br><span class="line">    console.log(&apos;Ignored&apos;)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>事件绑定好了，我们来触发一下这个事件，看看我们绑定的监听者会不会生效，然而触发事件我们<br>只需要调用它的emit方法就可以了，就像这样</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myEvent.emit(&apos;hello&apos;);</span><br></pre></td></tr></table></figure>
<p>执行的结果如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hello back</span><br><span class="line">Ignored</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="3-自己写一个山寨版的事件系统"><a href="#3-自己写一个山寨版的事件系统" class="headerlink" title="3.自己写一个山寨版的事件系统"></a>3.自己写一个山寨版的事件系统</h3><p>在学习编程中有一个很好的方法，就是 “山寨”，或者发明轮子，其实就是通过实现一个已经有的功能来加深对这个<br>功能的理解，那么我们也来“山寨”一个最简单的事件系统吧，来看看事件到底是个什么东西。</p>
<ol>
<li><p>首先，我们知道了NodeJS的事件模块是个构造函数，所以我们也来写一个构造函数。这里我们给一个空对象，这个对象会<br>用来存放各类的事件（event），比如之前我们用过的hello事件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function Events()&#123;</span><br><span class="line">    this.events = &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>刚才我们一共使用了两个方法，on和emit对吧，这里我们也要在原型上扩展这两个方法，以达到让“山寨版”可以像“正版”一样工作。<br>首先on可以接受两个参数，一个是事件的名字（hello），另一个是事件触发时需要执行的方法，而emit只需要接受一个事件名就可以了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Events.prototype.on = function(type, responseFunction)&#123;</span><br><span class="line">  </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Events.prototype.emit = function(type)&#123;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>想想当on方法执行时发生了什么，它把一个方法绑定到一个事件上了，所以大概是这样的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Events.prototype.on = function(type, responseFunction)&#123;</span><br><span class="line">    this.events[type] = responseFunction;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这里说明一下，在</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function Events()&#123;</span><br><span class="line">    this.events = &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>中，this.events这个object大概会是一个这样的结构，每个受到绑定的事件都会对应相应的方法，就像这样</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    hello: function()&#123;...&#125;,</span><br><span class="line">    fileLoaded: function()&#123;...&#125;,</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>比如，当hello被触发时，里面的function就会执行。</p>
</li>
<li><p>同理，我们再来想想当调用了emit方法时发生了什么，对，事件对应的方法被执行了，所以大概会是这样，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Events.prototype.emit = function(type)&#123;</span><br><span class="line">    this.events[type]();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>注意，这里说明一下，我们调用某个object上的一个方法或者访问这个object上的某个属性时，可以通过两种方法：<br>一是通过打点的方法，比如<code>obj.xxx</code>（属性），<code>obj.xxx()</code>（方法）；<br>二是通过方括号的方法，比如<code>obj[&#39;xxx&#39;]</code>（属性），<code>obj[&#39;xxx&#39;]()</code>（方法）。<br>但是这里我们只能用后者，因为我们不是要调用this.events的type属性而是要调用通过type传进来的那个属性，<br>换句话说，type是个变量，它的值才是我们真正要调用的，比如events.hello。</p>
</li>
<li><p>好了，这样就差不多了。哦，对了！一会别的文件要引用这个模块，所以我们要导出一下，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">module.exports = Events;</span><br></pre></td></tr></table></figure>
</li>
<li><p>来执行一下吧，把刚才的<code>require(&#39;events&#39;)</code>换成我们的“山寨版”吧<code>require(&#39;./modules/myEvents&#39;)</code>，<br>走起！！！<br>输出：<br><code>Ignored</code><br>Yeah！！！<br>等等，好像哪里不对啊，刚才明明绑定了两个监听者现在怎么只输出了一个啊？这什么情况。。。</p>
</li>
</ol>
<h3 id="3-山寨版改造"><a href="#3-山寨版改造" class="headerlink" title="3.山寨版改造"></a>3.山寨版改造</h3><ol>
<li><p>通过分析刚才我们写的代码，很明显，每次我们调用on方法时，会给event实例重新赋值，换句话说，之后的会覆盖之前的，<br>所以要让我们的“山寨版具有和”正版一样对一个事件多次绑定的功能，我们需要用一个集合来存放同一事件绑定的所有监听者，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Events.prototype.on = function(type, responseFunction)&#123;</span><br><span class="line">    if(this.events[type])&#123;</span><br><span class="line">        this.events[type].push(responseFunction);</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        this.events[type] = [];</span><br><span class="line">        this.events[type].push(responseFunction);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这里的逻辑是，如果一个事件（event）之前已经定义过了，那我们就直接在这个事件所对应的监听者数组里push新绑定的方法，<br>如果没有定义过，那么就定义一个空监听者数组，然后把对应的方法push进去。说白了，第一次我们绑定hello这个事件的时候，<br>实例的events上并没有这个叫hello的属性，那么我们定义一个数组，然后把hello对应的方法push进去，第二次我们发现已经<br>有hello了，就在相应的数组里push一个新的方法。hello这个事件大概是这样的<br>第一次：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//on执行前</span><br><span class="line">events:&#123;&#125;</span><br><span class="line">//on执行后</span><br><span class="line">events:&#123;</span><br><span class="line">    hello: [function()&#123;...&#125;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第二次</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//on执行前</span><br><span class="line">events:&#123;</span><br><span class="line">    hello: [function()&#123;...&#125;]</span><br><span class="line">&#125;</span><br><span class="line">//on执行后</span><br><span class="line">events:&#123;</span><br><span class="line">    hello: [function()&#123;...&#125;, function()&#123;...&#125;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以对这段代码进行一下简化，说白了就是想少写点字</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Events.prototype.on = function(type, responseFunction)&#123;</span><br><span class="line">    this.events[type] = this.events[type] || [];</span><br><span class="line">    this.events[type].push(responseFunction);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>OK，on这个方法就大概写完了。</p>
</li>
<li><p>既然events.hello已经是一个包含了多个function的数组，所以我们不能像之前那样<br><code>this.events[type]();</code>简单粗暴的直接调用了，我们需要执行数组里的每一个function，也就是<br>对这个数组进行一下遍历，这里有很多种方法，我们用forEach，因为效率比较高。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Events.prototype.emit = function(type)&#123;</span><br><span class="line">    this.events[type].forEach(function(responseFunc)&#123;</span><br><span class="line">        responseFunc();</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>好了，到这里这个“山寨版”也就差不多完成了，我们来跑跑吧：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hello back</span><br><span class="line">Ignored</span><br></pre></td></tr></table></figure>
<p>非常好！这样我们的“山寨版”也能绑定多个监听者了。</p>
</li>
</ol>
<p>完整代码如下<br>./modules/myEvents.js<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function Events()&#123;</span><br><span class="line">    this.events = &#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Events.prototype.on = function(type, responseFunction)&#123;</span><br><span class="line">    this.events[type] = this.events[type] || [];</span><br><span class="line">    this.events[type].push(responseFunction);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Events.prototype.emit = function(type)&#123;</span><br><span class="line">    this.events[type].forEach(function(responseFunc)&#123;</span><br><span class="line">        responseFunc();</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">module.exports = Events;</span><br></pre></td></tr></table></figure></p>
<p>./app.js<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var Events = require(&apos;./modules/myEvents&apos;);</span><br><span class="line"></span><br><span class="line">var myEvent = new Events();</span><br><span class="line"></span><br><span class="line">myEvent.on(&apos;hello&apos;, function()&#123;</span><br><span class="line">    console.log(&apos;hello back&apos;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">myEvent.on(&apos;hello&apos;, function()&#123;</span><br><span class="line">    console.log(&apos;Ignored&apos;)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">myEvent.emit(&apos;hello&apos;);</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<h3 id="4-总结"><a href="#4-总结" class="headerlink" title="4.总结"></a>4.总结</h3><p>我们写了一个“山寨版”的事件绑定和发布系统，但是山寨毕竟是山寨，我们看看NodeJS源码中的Events模块。。。<br><strong>我滴神呐。。。同样是程序猿，代码的差距咋就这么大捏。。。</strong><br>那是当然，人家的代码有很多我们没有的方法，而且人家有很多异常处理等等。但是如果你仔细看正版的on和emit方法<br>会发现其实他们实现的方法和我们的差不太多，那是当然，我是看过源码才。。。我是说。。。我是受到了源码的启发<br>才写的这篇博客。</p>
<h3 id="5-参考资料"><a href="#5-参考资料" class="headerlink" title="5.参考资料"></a>5.参考资料</h3><ol>
<li><a href="https://nodejs.org/dist/latest-v6.x/docs/api/events.html" target="_blank" rel="external">官方文档</a></li>
<li><a href="https://github.com/nodejs/node" target="_blank" rel="external">NodeJS源码</a></li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Node中的module和require]]></title>
      <url>http://yoursite.com/cir0xtdcu000b8gwz5ilkf5bv/</url>
      <content type="html"><![CDATA[<h2 id="Node中的模块"><a href="#Node中的模块" class="headerlink" title="Node中的模块"></a>Node中的模块</h2><p>在Node中，很大的一个组成部分就是模块，其中有Node中的core模块，有从npm上下载的第三方模块以及我们自己写的模块。<br>NodeJS在模块化方面使用的是exports和require来导入和导出。</p>
<a id="more"></a>
<p>这里我写了几个小例子来和大家分享一下exports的几种简单方法。文件目录大概是这样</p>
<img src="/cir0xtdcu000b8gwz5ilkf5bv/module_example.png" alt="module_example.png" title="">
<h3 id="1-直接导出"><a href="#1-直接导出" class="headerlink" title="1.直接导出"></a>1.直接导出</h3><p> ./modules/hello1.js<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">module.exports = function()&#123;</span><br><span class="line">    console.log(&apos;hello world 1&apos;)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>这是一种很简单的到处方法，module.expots可以理解成是一个空对象（{}），而导出的方法就是直接用自己写好的function或者<br>object来替换这个对象。</p>
<p> ./app.js<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var hello1 = require(&apos;./modules/hello1&apos;);</span><br><span class="line">hello1();</span><br></pre></td></tr></table></figure></p>
<h3 id="2-作为exports的一个属性导出"><a href="#2-作为exports的一个属性导出" class="headerlink" title="2.作为exports的一个属性导出"></a>2.作为exports的一个属性导出</h3><p> ./modules/hello2.js<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var hello = function()&#123;</span><br><span class="line">    console.log(&apos;hello world 2&apos;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">module.exports.hello = hello;</span><br></pre></td></tr></table></figure><br>为module.exports增加一个名为hello的属性</p>
<p> ./app.js<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var hello2 = require(&apos;./modules/hello2&apos;);</span><br><span class="line">hello2.hello();</span><br></pre></td></tr></table></figure></p>
<h3 id="3-用一个实例来替换module-exports"><a href="#3-用一个实例来替换module-exports" class="headerlink" title="3. 用一个实例来替换module.exports"></a>3. 用一个实例来替换module.exports</h3><p> ./modules/hello3.js<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var hello3 = function()&#123;</span><br><span class="line">    this.word = &apos;hello world 3&apos;;</span><br><span class="line">    this.hello = function()&#123;</span><br><span class="line">        console.log(this.word)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">module.exports = new hello3();</span><br></pre></td></tr></table></figure><br>这里可以看到，首先我们写一个构造函数用来生成实例，然后把一个新生成的实例赋给module.exports，就像这样：</p>
<p> ./app.js<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var hello3a = require(&apos;./modules/hello3&apos;);</span><br><span class="line">hello3a.hello();</span><br></pre></td></tr></table></figure><br>但是，如果我们改变hello3a的属性会怎么样呢？按理说实例都是各自独立的，hello3a的属性改变了应该不会影响其他的实例啊，<br>让我们来做个实验吧</p>
<ul>
<li>./app.js<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var hello3a = require(&apos;./modules/hello3&apos;);</span><br><span class="line">hello3a.hello();</span><br><span class="line">//这里word属性已经改变了</span><br><span class="line">hello3a.word = &apos;Good bye&apos;;</span><br><span class="line"></span><br><span class="line">var hello3b = require(&apos;./modules/hello3&apos;);</span><br><span class="line">hello3b.hello();</span><br><span class="line"></span><br><span class="line">//输出是这样的</span><br><span class="line">//hello world 3</span><br><span class="line">//Good bye</span><br></pre></td></tr></table></figure>
为什么啊？！我不是只改变了hello3a的word属性吗，为什么hello3b也会受到影响？！<br>其实，module.exports是有缓存机制的，只要一个模块生成了一次，之后所有对这个模块的require都会判断是否存在这个模块的缓存，<br>如果有，就会返回这份缓存。也就是说，不管一个模块被require多少次，其实都是require的同一个模块。那么上面的例子我该怎么让这两个实例<br>真正的做到独立存在呢？</li>
</ul>
<h3 id="4-导出一个构造函数"><a href="#4-导出一个构造函数" class="headerlink" title="4. 导出一个构造函数"></a>4. 导出一个构造函数</h3><p> ./modules/hello4.js<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var HelloCreator = function()&#123;</span><br><span class="line">    this.word = &apos;hello world 4&apos;;</span><br><span class="line">    this.hello = function()&#123;</span><br><span class="line">        console.log(this.word);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">module.exports = HelloCreator;</span><br></pre></td></tr></table></figure><br>其实很简单，只要导出那个构造函数就行了，谁需要实例就去自己new吧</p>
<p> ./app.js<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var Hello = require(&apos;./modules/hello4&apos;);</span><br><span class="line">var hello4a = new Hello();</span><br><span class="line"></span><br><span class="line">hello4a.word = &apos;Good bye&apos;;</span><br><span class="line">hello4a.hello();</span><br><span class="line"></span><br><span class="line">var hello4b = new Hello();</span><br><span class="line">hello4b.hello();</span><br></pre></td></tr></table></figure><br>当然了，我们不能直接使用这个模块，因为它仅仅只是个构造函数，所以只要new一下就可以了。</p>
<h3 id="5-只把想要暴露的方法和属性暴露出去"><a href="#5-只把想要暴露的方法和属性暴露出去" class="headerlink" title="5. 只把想要暴露的方法和属性暴露出去"></a>5. 只把想要暴露的方法和属性暴露出去</h3><p> ./modules/hello5.js<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var word = &apos;Hello world 5&apos;;</span><br><span class="line">var word2 = &apos;Good bye&apos;;</span><br><span class="line"></span><br><span class="line">var hello = function()&#123;</span><br><span class="line">    console.log(word);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var bye = function()&#123;</span><br><span class="line">    console.log(word2);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">    hello: hello,</span><br><span class="line">    bye: bye</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>在这个例子里，我们只把hello和bye这两个方法暴露给外界，对于其他的属性和方法，外界是无法访问到的。这样做在某种意义上保证了隐秘数据不会被外界<br>访问到，而且还增加了模块的可控性。</p>
<p> ./app.js<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var hello5 = require(&apos;./modules/hello5&apos;);</span><br><span class="line">hello5.hello();</span><br><span class="line">hello5.bye();</span><br></pre></td></tr></table></figure></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>定义模块和获得模块的方法有很多，以上只是列举了几种比较常见的，希望能对新入坑的小伙伴们有所帮助。其实我认为没有哪种方法是绝对好或者绝对不好的<br>具体使用哪种方法写模块或者导出模块还是要看具体的业务需求。</p>
]]></content>
    </entry>
    
  
  
</search>
